#!/usr/bin/env python

import subprocess

import os

import signal

import threading




import types

utils = types.SimpleNamespace()
def YinMDtgBlH():
     import subprocess
     
     import re
     
     import tempfile
     
     import os
     
     import pathlib
     
     import signal 
     
     import time
     
     import sys
     
     import typing
     
     
     
     def tempdir():
     
         if os.uname().sysname=="Darwin":
     
             return "/tmp"
     
         else:
     
             return tempfile.gettempdir()
     
         
     
     TEMPDIR=tempdir()
     
     
     
     
     
     class DoesNotExist(Exception):
     
         pass
     
     
     
     def get_root_directory(class_name,root_variable=None,default_value=None):
     
         root_variable=get_value(root_variable,f"{class_name.upper()}_ROOT")
     
         default_value=get_value(default_value,f"{os.environ['HOME']}/{class_name.title()}s")
     
         return os.path.expanduser(os.getenv(root_variable,default_value))
     
         
     
     #ROOT=get_root_directory()
     
     
     
     def list_items_in_root(names,flags,class_name):
     
         All=[_ for _ in sorted(os.listdir(ROOT)) if not _.startswith('.') ]
     
         
     
         if "--started" in flags:
     
             names+=[_ for _ in All if "Started" in eval(f"{class_name}(_).Status()") ]
     
             flags.remove("--started")
     
         if "--stopped" in flags:
     
             names+=[_ for _ in All if "Stopped" in eval(f"{class_name}(_).Status()") ]
     
             flags.remove("--stopped")
     
         if "--enabled" in flags:
     
             names+=[_ for _ in All if "Enabled" in eval(f"{class_name}(_).Status()") ]
     
             flags.remove("--enabled")
     
         
     
         if "--disabled" in flags:
     
             names+=[_ for _ in All if "Disabled" in eval(f"{class_name}(_).Status()") ]
     
             flags.remove("--disabled")
     
     
     
         if "--all" in flags:
     
             names+=All
     
             flags.remove("--all")
     
         if names==[]:
     
             print(f"No {class_name}s specified!")
     
             exit()
     
     
     
         return names
     
     
     
     def flatten_list(items):
     
         """Yield items from any nested iterable."""
     
         for x in items:
     
             if isinstance(x, typing.Iterable) and not isinstance(x, (str, bytes)):
     
                 for sub_x in flatten_list(x):
     
                     yield sub_x
     
             else:
     
                 yield x
     
     
     
     def print_list(l):
     
         for element in l:
     
             if element is None:
     
                 print(end='')
     
             else:
     
                 print(element)
     
     
     
     def split_string_by_char(string,char=':'):
     
         PATTERN = re.compile(rf'''((?:[^\{char}"']|"[^"]*"|'[^']*')+)''')
     
         return [_ for _ in list(PATTERN.split(string)) if _ not in ['', char]]
     
     
     
     
     
     def shell_command(command,stdout=subprocess.PIPE,stderr=subprocess.STDOUT,arbitrary=False,block=True):
     
         process = subprocess.Popen(command, stdout=stdout, stderr=stderr,universal_newlines=True,shell=arbitrary)
     
         if block:
     
             return process.communicate()[0]
     
     
     
     
     
     def get_value(variable,default):
     
         if not variable:
     
             return default
     
         else:
     
             return variable
     
     
     
     def extract_arguments():
     
         arguments=sys.argv[1:]
     
         try:
     
             FUNCTION=arguments[0]
     
         except IndexError:
     
             print("No function specified!")
     
             exit()
     
         arguments=arguments[1:]
     
         
     
         NAMES=[]
     
         FLAGS=arguments
     
         for i in range(len(arguments)):
     
             if not arguments[i].startswith("--"):
     
                 FLAGS=arguments[:i]
     
                 NAMES=arguments[i:]
     
                 break
     
         return (NAMES,FLAGS,FUNCTION)
     
     
     
     def add_environment_variable_to_string(string,env_var):
     
         return string+f"; export {env_var}"
     
     
     
     def wait(delay=None):
     
         if not delay:
     
             signal.pause()
     
         else:
     
             time.sleep(int(delay))
     
     
     
     def execute_class_method(class_instance,function):
     
         if not callable(getattr(class_instance, function.title(),None)):
     
                 print(f"Command {function} doesn't exist!")
     
                 exit()
     
         else:
     
             return list(flatten([getattr(class_instance,function.title())()]))
     
     
     
     def export_methods_globally(class_instance_string):
     
         Class=eval(f"{class_instance_string}.__class__")
     
         for func in [func for func in dir(Class) if callable(getattr(Class, func)) and not func.startswith('__')]:
     
             exec(f"global {func}",globals())
     
             exec(f"{func} = {class_instance_string}.{func}",globals())
     
     
     
     class Class:
     
         def __init__(self,class_self,class_name):
     
             self.self=class_self
     
             self.name=class_name
     
         
     
         def class_init(self,_name,_flags=None,_function=None):
     
             self.self.name=_name
     
             
     
             self.self.flags=get_value(_flags,FLAGS)
     
             
     
             self.self.function=get_value(_function,FUNCTION)
     
             
     
             if self.self.function not in ["init"]:
     
                 if not os.path.isdir(f"{ROOT}/{self.self.name}"):
     
                      raise DoesNotExist()
     
                      return
     
                 os.chdir(f"{ROOT}/{self.self.name}")
     
         def stop(self):
     
             if "Stopped" in self.self.Status():
     
                 return f"Service {self.self.name} is already stopped"
     
             
     
             for process in ["main", "auxiliary"]:
     
                 for pid in self.self.Ps(process):
     
                     os.kill(pid,signal.SIGTERM)
     
             
     
         def cleanup_after_stop(self):
     
             for ending in ["log","lock"]:
     
                 try:
     
                    os.remove(f"{TEMPDIR}/{self.name}_{self.self.name}.{ending}")
     
                 except FileNotFoundError:
     
                     pass
     
     
     
         def restart(self):
     
             return [self.self.Stop(),self.self.Start()]
     
         
     
         def get_main_process(self):
     
             if not os.path.isfile(f"{TEMPDIR}/{self.name}_{self.self.name}.lock"):
     
                     return []
     
             else:
     
                 return list(map(int,[_[1:] for _ in shell_command(["lsof","-Fp","-w",f"{TEMPDIR}/{self.name}_{self.self.name}.lock"]).splitlines()]))
     
         
     
         def list(self):
     
             return self.self.name
     
     
     
         def edit(self):
     
             if "Enabled" in self.self.Status():
     
                 Shell([os.getenv("EDITOR","vi"),f"{ROOT}/{self.self.name}/{self.name}.py"],stdout=None)
     
             else:
     
                 Shell([os.getenv("EDITOR","vi"),f"{ROOT}/{self.self.name}/.{self.name}.py"],stdout=None)
     
     
     
         def status(self):
     
             status=[]
     
             if os.path.isfile(f"{TEMPDIR}/{self.name}_{self.self.name}.log"):
     
                 status+=["Started"]
     
             else:
     
                 status+=["Stopped"]
     
             
     
             if os.path.exists(f"{ROOT}/{self.self.name}/{self.name}.py"):
     
                 status+=["Enabled"]
     
             else:
     
                 status+=["Disabled"]
     
             return status
     
         
     
         def enable(self):
     
             if "Enabled" in self.self.Status():
     
                 return [f"{self.name} is already enabled"]
     
             else:
     
                 os.rename(f"{ROOT}/{self.self.name}/.{self.name}.py",f"{ROOT}/{self.self.name}/{self.name}.py")
     
             
     
             if '--now' in self.self.flags:
     
                 return [self.self.Start()]
     
     
     
                 
     
         def disable(self):
     
             if "Disabled" in self.self.Status():
     
                 return [f"{self.self.name} is already disabled"]
     
             else:
     
                 os.rename(f"{ROOT}/{self.self.name}/{self.name}.py",f"{ROOT}/{self.self.name}/.{self.name}.py")
     
             
     
             if '--now' in self.self.flags:
     
                 return [self.self.Stop()]
     
     
     
         def log(self):
     
             Shell(["less","+G",f"{TEMPDIR}/{self.name}_{self.self.name}.log"],stdout=None)
     
         
     
         def delete(self):
     
             self.self.Stop()
     
             shutil.rmtree(self.self.name)
     
         
     
         def watch(self):
     
             Shell(["tail","-f",f"{TEMPDIR}/{self.name}_{self.self.name}.log"],stdout=None)
     
     
     local_variables=locals().copy()
     for key in local_variables:
        exec(f"utils.{key} = {key}")

YinMDtgBlH()



CLASS_NAME="Service"

ROOT=utils.get_root_directory(CLASS_NAME)



NAMES,FLAGS,FUNCTION=utils.extract_arguments()



TEMPDIR=utils.TEMPDIR



SHELL=os.getenv('SHELL','bash')

SHELL_CWD=os.environ.get("PWD")





def list_services(*args, **kwargs):

    return utils.list_items_in_root(*args, FLAGS,CLASS_NAME,**kwargs)    



def flatten(*args, **kwargs):

    return utils.flatten_list(*args, **kwargs)



def print_result(*args, **kwargs):

    return utils.print_list(*args, **kwargs)



def split_by_char(*args, **kwargs):

    return utils.split_by_char(*args, **kwargs)

    

def Shell(*args, **kwargs):

    return utils.shell_command(*args, **kwargs)





ServiceDoesNotExist=utils.DoesNotExist

    

class Service:

    def __init__(self,_name,_flags=None,_function=None,_env=None):

        self.Class = utils.Class(self,CLASS_NAME.lower())

        self.Class.class_init(_name,_flags,_function)

        

        self.env=utils.get_value(_env,f"export SERVICE_NAME={self.name}")

    

    #Functions to be used in *service.py

    def Run(self,command="",pipe=False):

        with open(f"{TEMPDIR}/service_{self.name}.log","a+") as log_file:

            log_file.write(f"Command: {command}\n")

            log_file.flush()



            #Pipe output to variable

            if pipe:

                stdout=subprocess.PIPE

                stderr=subprocess.DEVNULL

            #Print output to file

            else:

                stdout=log_file

                stderr=subprocess.STDOUT

            return Shell(f"{self.env}; {command}",stdout=stdout,stderr=stderr,arbitrary=True)

    

    def Ps(self,process="auxiliary"):

        

        #Find main process

        if process=="main":

            return self.Class.get_main_process()

            

        #Find processes running under main Start script

        elif process=="auxiliary":

            processes=Shell(["ps","auwwe"]).splitlines()

            processes=[_.split()[1] for _ in processes if f"SERVICE_NAME={self.name}" in _]

            return list(map(int,processes))



    

    def Env(self,*args, **kwargs):

        self.env=utils.add_environment_variable_to_string(self.env,*args, **kwargs)

    

    def Container(self,_container=None):

        #Convience --- if conainer name is not specified, it will assume that the container is the same name as the service

        

        if not _container:

            _container=self.name

            

        self.Down(f"container stop {_container}; sleep 1")

        self.Run(f"container start {_container}")

        

        #Wait 2 seconds before beginning

        self.Wait(2)

        with open(f"{TEMPDIR}/service_{self.name}.log","a+") as f:

            Shell(["tail","-f","-n","+1",f"{TEMPDIR}/container_{_container}.log"],stdout=f,block=False)

    

    def Down(self,func):

        #Yes, this decorator stuff is absolutely neccessary, anything else will not work

    

        if isinstance(func,str):

            #So func won't be overwritten

            func_str=func

            def func():

                Shell(func_str,arbitrary=True)

        def decorator_Exit(exit_func):

            def new_Exit(*args, **kwargs):

                #So exit() is the last function run

                func()

                exit_func(*args, **kwargs)

            return new_Exit

        self.Exit=decorator_Exit(self.Exit)

        signal.signal(signal.SIGTERM,self.Exit)

        

    def Loop(self,command,delay=60):

        if isinstance(command,str):

            def func():

                while True:

                    Run(command)

                    self.Wait(delay)

        else:

            def func():

                while True:  

                    command()

                    self.Wait(delay)

        threading.Thread(target=func).start()



    def Wait(self,*args, **kwargs):

        utils.wait(*args, **kwargs)

    

    def Exit(self,signum,frame):

        exit()

        

    #Commands      

    def Start(self):

        

        if "Started" in self.Status():

            return f"Service {self.name} is already started"

        

        if os.path.exists("data"):

            os.chdir("data")

        

        if "Enabled" in self.Status():

            service_file="service.py"

        else:

            service_file=".service.py"

        

        #Fork process, so it can run in the background

        pid=os.fork()

        

        #If child, run code, then exit 

        if pid==0:

            #Open a lock file so I can find it with lsof later

            signal.signal(signal.SIGTERM,self.Exit)

            lock_file=open(f"{TEMPDIR}/service_{self.name}.lock","w+")

            

            #Run *service.py

            with open(f"{ROOT}/{self.name}/{service_file}") as f:

                code=f.read()

            exec(code,globals(),locals())

            

            #Don't exit script yet.

            self.Wait()

            exit()

       

    def Stop(self):

        output=[self.Class.stop()]

        self.Class.cleanup_after_stop()

        return output

        

    def Restart(self):

        return self.Class.restart()

    

    

    def List(self):

        return self.Class.list()



    def Init(self):

        os.makedirs(f"{ROOT}/{self.self.name}",exist_ok=True)

        os.chdir(f"{ROOT}/{self.self.name}")

        os.makedirs("data",exist_ok=True)

        with open(f".{self.name}.py",'a'):

            pass

        

        if '--no-edit' not in self.flags:

            self.self.Edit()



    def Edit(self):

        self.Class.edit()

    def Status(self):

        return self.Class.status()

    

    def Enable(self):

        return self.Class.enable()



            

    def Disable(self):

        return self.Class.disable()



    def Log(self):

        self.Class.log()

    

    def Delete(self):

        self.Class.stop()

    

    def Watch(self):

        self.Class.watch()





NAMES=list_services(NAMES)

for name in NAMES: 

    try:

        service=Service(name,FLAGS)

    except ServiceDoesNotExist:

        print(f"Service {name} does not exist")

        continue

    

    utils.export_methods_globally(CLASS_NAME.lower())

    

    result=utils.execute_class_method(eval(f"{CLASS_NAME.lower()}"),FUNCTION)

    print_result(result)

        



    
