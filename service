#!/usr/bin/env python
import subprocess
import os
import signal
import threading



import types
import sys
import base64
utils_module=types.ModuleType("utils")
#setattr(utils_module,"__file__",__file__)
exec(base64.b64decode(b'aW1wb3J0IHN1YnByb2Nlc3MKaW1wb3J0IHJlCmltcG9ydCB0ZW1wZmlsZQppbXBvcnQgb3MKaW1wb3J0IHBhdGhsaWIKaW1wb3J0IHNpZ25hbCAKaW1wb3J0IHRpbWUKaW1wb3J0IHN5cwppbXBvcnQgdHlwaW5nCmltcG9ydCBzaHV0aWwKaW1wb3J0IHRocmVhZGluZwppbXBvcnQgY29udGV4dGxpYgoKZGVmIGdldF90ZW1wZGlyKCk6CiAgICBpZiBvcy51bmFtZSgpLnN5c25hbWU9PSJEYXJ3aW4iOgogICAgICAgIHJldHVybiAiL3RtcCIKICAgIGVsc2U6CiAgICAgICAgcmV0dXJuIHRlbXBmaWxlLmdldHRlbXBkaXIoKQogICAgCgoKCmNsYXNzIERvZXNOb3RFeGlzdChFeGNlcHRpb24pOgogICAgcGFzcwoKZGVmIGdldF92YWx1ZSh2YXJpYWJsZSxkZWZhdWx0KToKCWlmIG5vdCB2YXJpYWJsZToKCQlyZXR1cm4gZGVmYXVsdAoJZWxzZToKCQlyZXR1cm4gdmFyaWFibGUKCmRlZiBnZXRfcm9vdF9kaXJlY3RvcnkoY2xhc3NfbmFtZSxyb290X3ZhcmlhYmxlPU5vbmUsZGVmYXVsdF92YWx1ZT1Ob25lKToKICAgIHJvb3RfdmFyaWFibGU9Z2V0X3ZhbHVlKHJvb3RfdmFyaWFibGUsZiJ7Y2xhc3NfbmFtZS51cHBlcigpfV9ST09UIikKICAgIGRlZmF1bHRfdmFsdWU9Z2V0X3ZhbHVlKGRlZmF1bHRfdmFsdWUsZiJ7b3MuZW52aXJvblsnSE9NRSddfS97Y2xhc3NfbmFtZS50aXRsZSgpfXMiKQogICAgcmV0dXJuIG9zLnBhdGguZXhwYW5kdXNlcihvcy5nZXRlbnYocm9vdF92YXJpYWJsZSxkZWZhdWx0X3ZhbHVlKSkKCmZvciB2YXIgaW4gWyJST09UIiwgIk5BTUVTIiwiVEVNUERJUiIsIkdMT0JBTFMiXToKICAgIGdsb2JhbHMoKVt2YXJdPU5vbmUgIAogICAgCiNST09UPU5vbmUKI05BTUVTPU5vbmUKI0ZMQUdTPU5vbmUKI0ZVTkNUSU9OPU5vbmUKI1RFTVBESVI9Tm9uZQoKZGVmIGxpc3RfaXRlbXNfaW5fcm9vdChuYW1lcyxmbGFncyxjbGFzc19uYW1lKToKICAgIEFsbD1bXyBmb3IgXyBpbiBzb3J0ZWQob3MubGlzdGRpcihST09UKSkgaWYgbm90IF8uc3RhcnRzd2l0aCgnLicpIF0KICAgIAogICAgZm9yIGZsYWcgaW4gWyJzdGFydGVkIiwic3RvcHBlZCIsImVuYWJsZWQiLCJkaXNhYmxlZCJdOgogICAgICAgIGlmICItLSIrZmxhZyBpbiBmbGFnczoKICAgICAgICAgICAgbmFtZXMrPVtfIGZvciBfIGluIEFsbCBpZiBmbGFnLnRpdGxlKCkgaW4gZXZhbChmIntjbGFzc19uYW1lfShfKS5TdGF0dXMoKSIsR0xPQkFMUyxsb2NhbHMoKSkgXQogICAgICAgICAgICBmbGFncy5yZW1vdmUoIi0tIitmbGFnKQoKICAgIGlmICItLWFsbCIgaW4gZmxhZ3M6CiAgICAgICAgbmFtZXMrPUFsbAogICAgICAgIGZsYWdzLnJlbW92ZSgiLS1hbGwiKQogICAgaWYgbmFtZXM9PVtdOgogICAgICAgIHByaW50KGYiTm8ge2NsYXNzX25hbWV9cyBzcGVjaWZpZWQhIikKICAgICAgICBleGl0KCkKICAgIHJldHVybiBuYW1lcwoKZGVmIGZsYXR0ZW5fbGlzdChpdGVtcyk6CiAgICAiIiJZaWVsZCBpdGVtcyBmcm9tIGFueSBuZXN0ZWQgaXRlcmFibGUuIiIiCiAgICBmb3IgeCBpbiBpdGVtczoKICAgICAgICBpZiBpc2luc3RhbmNlKHgsIHR5cGluZy5JdGVyYWJsZSkgYW5kIG5vdCBpc2luc3RhbmNlKHgsIChzdHIsIGJ5dGVzKSk6CiAgICAgICAgICAgIGZvciBzdWJfeCBpbiBmbGF0dGVuX2xpc3QoeCk6CiAgICAgICAgICAgICAgICB5aWVsZCBzdWJfeAogICAgICAgIGVsc2U6CiAgICAgICAgICAgIHlpZWxkIHgKCmRlZiBwcmludF9saXN0KGwpOgogICAgZm9yIGVsZW1lbnQgaW4gbDoKICAgICAgICBpZiBlbGVtZW50IGlzIE5vbmU6CiAgICAgICAgICAgIHByaW50KGVuZD0nJykKICAgICAgICBlbHNlOgogICAgICAgICAgICBwcmludChlbGVtZW50KQoKZGVmIHNwbGl0X3N0cmluZ19ieV9jaGFyKHN0cmluZyxjaGFyPSc6Jyk6CiAgICBQQVRURVJOID0gcmUuY29tcGlsZShyZicnJygoPzpbXlx7Y2hhcn0iJ118IlteIl0qInwnW14nXSonKSspJycnKQogICAgcmV0dXJuIFtfIGZvciBfIGluIGxpc3QoUEFUVEVSTi5zcGxpdChzdHJpbmcpKSBpZiBfIG5vdCBpbiBbJycsIGNoYXJdXQoKCmRlZiBzaGVsbF9jb21tYW5kKGNvbW1hbmQsc3Rkb3V0PXN1YnByb2Nlc3MuUElQRSxzdGRlcnI9c3VicHJvY2Vzcy5TVERPVVQsYXJiaXRyYXJ5PUZhbHNlLGJsb2NrPVRydWUsZW52PU5vbmUpOgogICAgcHJvY2VzcyA9IHN1YnByb2Nlc3MuUG9wZW4oY29tbWFuZCwgc3Rkb3V0PXN0ZG91dCwgc3RkZXJyPXN0ZGVycix1bml2ZXJzYWxfbmV3bGluZXM9VHJ1ZSxzaGVsbD1hcmJpdHJhcnksZW52PWVudikKICAgIGlmIGJsb2NrOgogICAgICAgIHJldHVybiBwcm9jZXNzLmNvbW11bmljYXRlKClbMF0KCmRlZiB3YWl0X3VudGlsX3BpZF9leGl0cyhwaWQpOgogICAgCiAgICBkZWYgcGlkX2V4aXN0cyhwaWQpOiAgIAogICAgICAgICIiIiBDaGVjayBGb3IgdGhlIGV4aXN0ZW5jZSBvZiBhIHVuaXggcGlkLiAiIiIKICAgICAgICB0cnk6CiAgICAgICAgICAgIG9zLmtpbGwocGlkLCAwKQogICAgICAgIGV4Y2VwdCBPU0Vycm9yOgogICAgICAgICAgICByZXR1cm4gRmFsc2UKICAgICAgICBlbHNlOgogICAgICAgICAgICByZXR1cm4gVHJ1ZQogICAgICAgICAgICAKICAgIHdoaWxlIHBpZF9leGlzdHMocGlkKToKICAgICAgICB0aW1lLnNsZWVwKDAuMjUpCmRlZiBraWxsX3Byb2Nlc3NfZ3JhY2VmdWxseShwaWQpOgogICAgCiAgICB0cnk6CiAgICAgICAgb3Mua2lsbChwaWQsc2lnbmFsLlNJR1RFUk0pCiAgICAgICAgd2FpdF91bnRpbF9waWRfZXhpdHMocGlkKQogICAgZXhjZXB0IFByb2Nlc3NMb29rdXBFcnJvcjoKICAgICAgICBwYXNzCiAgICAKZGVmIGV4dHJhY3RfYXJndW1lbnRzKCk6CiAgICBhcmd1bWVudHM9c3lzLmFyZ3ZbMTpdCiAgICB0cnk6CiAgICAgICAgRlVOQ1RJT049YXJndW1lbnRzWzBdCiAgICBleGNlcHQgSW5kZXhFcnJvcjoKICAgICAgICBwcmludCgiTm8gZnVuY3Rpb24gc3BlY2lmaWVkISIpCiAgICAgICAgZXhpdCgpCiAgICBhcmd1bWVudHM9YXJndW1lbnRzWzE6XQogICAgCiAgICBOQU1FUz1bXQogICAgRkxBR1M9YXJndW1lbnRzCiAgICBmb3IgaSBpbiByYW5nZShsZW4oYXJndW1lbnRzKSk6CiAgICAgICAgaWYgbm90IGFyZ3VtZW50c1tpXS5zdGFydHN3aXRoKCItLSIpOgogICAgICAgICAgICBGTEFHUz1hcmd1bWVudHNbOmldCiAgICAgICAgICAgIE5BTUVTPWFyZ3VtZW50c1tpOl0KICAgICAgICAgICAgYnJlYWsKICAgIHJldHVybiAoTkFNRVMsRkxBR1MsRlVOQ1RJT04pCgpkZWYgYWRkX2Vudmlyb25tZW50X3ZhcmlhYmxlX3RvX3N0cmluZyhzdHJpbmcsZW52X3Zhcik6CiAgICByZXR1cm4gc3RyaW5nK2YiOyBleHBvcnQge2Vudl92YXJ9IgoKZGVmIHdhaXQoZGVsYXk9Tm9uZSk6CiAgICB0aHJlYWRpbmcuRXZlbnQoKS53YWl0KHRpbWVvdXQ9ZGVsYXkpCgpkZWYgZXhlY3V0ZV9jbGFzc19tZXRob2QoY2xhc3NfaW5zdGFuY2UsZnVuY3Rpb24pOgogICAgaWYgbm90IGNhbGxhYmxlKGdldGF0dHIoY2xhc3NfaW5zdGFuY2UsIGZ1bmN0aW9uLnRpdGxlKCksTm9uZSkpOgogICAgICAgICAgICBwcmludChmIkNvbW1hbmQge2Z1bmN0aW9ufSBkb2Vzbid0IGV4aXN0ISIpCiAgICAgICAgICAgIGV4aXQoKQogICAgZWxzZToKICAgICAgICByZXR1cm4gbGlzdChmbGF0dGVuX2xpc3QoW2dldGF0dHIoY2xhc3NfaW5zdGFuY2UsZnVuY3Rpb24udGl0bGUoKSkoKV0pKQoKZGVmIGNoZWNrX2lmX2VsZW1lbnRfYW55X2lzX2luX2xpc3QoZWxlbWVudHMsX2xpc3QpOgogICAgcmV0dXJuIGFueShfIGluIF9saXN0IGZvciBfIGluIGVsZW1lbnRzKQogICAgCmRlZiBleHBvcnRfbWV0aG9kc19nbG9iYWxseShjbGFzc19uYW1lKToKICAgIGZvciBmdW5jIGluIFtmdW5jIGZvciBmdW5jIGluIGRpcihldmFsKGNsYXNzX25hbWUsR0xPQkFMUykpIGlmIGNhbGxhYmxlKGdldGF0dHIoZXZhbChjbGFzc19uYW1lLEdMT0JBTFMpLCBmdW5jKSkgYW5kIG5vdCBmdW5jLnN0YXJ0c3dpdGgoJ19fJyldOgogICAgICAgIGV4ZWMoZiJnbG9iYWwge2Z1bmN9IixHTE9CQUxTKQogICAgICAgIGV4ZWMoZiJ7ZnVuY30gPSB7Y2xhc3NfbmFtZS5sb3dlcigpfS57ZnVuY30iLEdMT0JBTFMpCgpkZWYgd3JhcF9hbGxfbWV0aG9kc19pbl9jbGFzc193aXRoX2NoZGlyX2NvbnRleHRtYW5hZ2VyKHNlbGYscGF0aCk6CiAgICBAY29udGV4dGxpYi5jb250ZXh0bWFuYWdlcgogICAgZGVmIHNldF9kaXJlY3RvcnkocGF0aCk6CiAgICAgICAgIiIiU2V0cyB0aGUgY3dkIHdpdGhpbiB0aGUgY29udGV4dAogICAgCiAgICAgICAgQXJnczoKICAgICAgICAgICAgcGF0aCAoUGF0aCk6IFRoZSBwYXRoIHRvIHRoZSBjd2QKICAgIAogICAgICAgIFlpZWxkczoKICAgICAgICAgICAgTm9uZQogICAgICAgICIiIgogICAgCiAgICAgICAgb3JpZ2luID0gb3MucGF0aC5hYnNwYXRoKG9zLmdldGN3ZCgpKQogICAgICAgIHRyeToKICAgICAgICAgICAgb3MuY2hkaXIocGF0aCkKICAgICAgICAgICAgeWllbGQKICAgICAgICBmaW5hbGx5OgogICAgICAgICAgICAgICAgb3MuY2hkaXIob3JpZ2luKQogICAgCiAgICBkZWYgd3JhcHBlcihmdW5jKToKICAgICAgICBkZWYgbmV3X2Z1bmMoKmFyZ3MsICoqa3dhcmdzKToKICAgICAgICAgICAgd2l0aCBzZXRfZGlyZWN0b3J5KHBhdGgpOgogICAgICAgICAgICAgICAgZnVuYygqYXJncywgKiprd2FyZ3MpCiAgICAgICAgcmV0dXJuIG5ld19mdW5jCiAgICAgICAgICAgIAogICAgZm9yIGZ1bmMgaW4gW2Z1bmMgZm9yIGZ1bmMgaW4gZGlyKHNlbGYpIGlmIGNhbGxhYmxlKGdldGF0dHIoc2VsZiwgZnVuYykpIGFuZCBub3QgZnVuYy5zdGFydHN3aXRoKCdfXycpXToKICAgICAgICBzZXRhdHRyKHNlbGYsZnVuYyx3cmFwcGVyKGdldGF0dHIoc2VsZixmdW5jKSkpCmNsYXNzIENsYXNzOgogICAgZGVmIF9faW5pdF9fKHNlbGYsY2xhc3Nfc2VsZixjbGFzc19uYW1lKToKICAgICAgICBzZWxmLnNlbGY9Y2xhc3Nfc2VsZgogICAgICAgIHNlbGYubmFtZT1jbGFzc19uYW1lCiAgICAKICAgIGRlZiBjbGFzc19pbml0KHNlbGYsX25hbWUsX2ZsYWdzLF9mdW5jdGlvbixfd29ya2Rpcik6CiAgICAgICAgc2VsZi5zZWxmLm5hbWU9X25hbWUKICAgICAgICAKICAgICAgICBzZWxmLnNlbGYuZmxhZ3M9Z2V0X3ZhbHVlKF9mbGFncyxbXSkKICAgICAgICAKICAgICAgICBzZWxmLnNlbGYuZnVuY3Rpb249Z2V0X3ZhbHVlKF9mdW5jdGlvbiwiIikKICAgICAgICAKICAgICAgICBpZiBzZWxmLnNlbGYuZnVuY3Rpb24gbm90IGluIFsiaW5pdCJdOgogICAgICAgICAgICBpZiBub3Qgb3MucGF0aC5pc2RpcihmIntST09UfS97c2VsZi5zZWxmLm5hbWV9Iik6CiAgICAgICAgICAgICAgICAgcmFpc2UgRG9lc05vdEV4aXN0KCkKICAgICAgICAgICAgICAgICByZXR1cm4KICAgICAgICAgICAgd3JhcF9hbGxfbWV0aG9kc19pbl9jbGFzc193aXRoX2NoZGlyX2NvbnRleHRtYW5hZ2VyKHNlbGYsZiJ7Uk9PVH0ve3NlbGYuc2VsZi5uYW1lfSIpCiAgICAgICAgc2VsZi5zZWxmLndvcmtkaXI9X3dvcmtkaXIKICAgICAgICAKICAgIGRlZiBzdG9wKHNlbGYpOgogICAgICAgIGlmICJTdG9wcGVkIiBpbiBzZWxmLnNlbGYuU3RhdHVzKCk6CiAgICAgICAgICAgIHJldHVybiBmIlNlcnZpY2Uge3NlbGYuc2VsZi5uYW1lfSBpcyBhbHJlYWR5IHN0b3BwZWQiCiAgICAgICAgCiAgICAgICAgZm9yIHBpZCBpbiBzZWxmLnNlbGYuUHMoIm1haW4iKToKICAgICAgICAgICAga2lsbF9wcm9jZXNzX2dyYWNlZnVsbHkocGlkKQogICAgICAgIAogICAgICAgIGZvciBlbmRpbmcgaW4gWyJsb2ciLCJsb2NrIl06CiAgICAgICAgICAgIHRyeToKICAgICAgICAgICAgICAgb3MucmVtb3ZlKGYie1RFTVBESVJ9L3tzZWxmLm5hbWV9X3tzZWxmLnNlbGYubmFtZX0ue2VuZGluZ30iKQogICAgICAgICAgICBleGNlcHQgRmlsZU5vdEZvdW5kRXJyb3I6CiAgICAgICAgICAgICAgICBwYXNzCgogICAgZGVmIHJlc3RhcnQoc2VsZik6CiAgICAgICAgcmV0dXJuIFtzZWxmLnNlbGYuU3RvcCgpLHNlbGYuc2VsZi5TdGFydCgpXQogICAgCiAgICBkZWYgZ2V0X21haW5fcHJvY2VzcyhzZWxmKToKICAgICAgICBpZiBub3Qgb3MucGF0aC5pc2ZpbGUoZiJ7VEVNUERJUn0ve3NlbGYubmFtZX1fe3NlbGYuc2VsZi5uYW1lfS5sb2NrIik6CiAgICAgICAgICAgICAgICByZXR1cm4gW10KICAgICAgICBlbHNlOgogICAgICAgICAgICByZXR1cm4gbGlzdChtYXAoaW50LFtfWzE6XSBmb3IgXyBpbiBzaGVsbF9jb21tYW5kKFsibHNvZiIsIi1GcCIsIi13IixmIntURU1QRElSfS97c2VsZi5uYW1lfV97c2VsZi5zZWxmLm5hbWV9LmxvY2siXSkuc3BsaXRsaW5lcygpXSkpCiAgICAKICAgIGRlZiBsaXN0KHNlbGYpOgogICAgICAgIHJldHVybiBzZWxmLnNlbGYubmFtZQogICAgICAgIAogICAgZGVmIHdvcmtkaXIoc2VsZix3b3JrX2Rpcik6CiAgICAgICAgI1JlbW92ZSB0cmFpbGluZyBzbGFzaGVzLCBidXQgb25seSBmb3Igc3RyaW5ncyB0aGF0IGFyZSBub3QgLwogICAgICAgIGlmIHdvcmtfZGlyLmVuZHN3aXRoKCcvJykgYW5kIGxlbih3b3JrX2Rpcik+MToKICAgICAgICAgICAgd29ya19kaXI9d29ya19kaXJbOi0xXQogICAgICAgICAgICAKICAgICAgICBpZiB3b3JrX2Rpci5zdGFydHN3aXRoKCIvIik6CiAgICAgICAgICAgIHNlbGYuc2VsZi53b3JrZGlyPXdvcmtfZGlyCiAgICAgICAgZWxzZTogICAgCiAgICAgICAgICAgIHNlbGYuc2VsZi53b3JrZGlyKz0nLycrd29ya19kaXIKICAgICAgICAKICAgICAgICAjUmVtb3ZlIHJlcGVhdGVkIC8gaW4gd29ya2RpcgogICAgICAgIHNlbGYuc2VsZi53b3JrZGlyPXJlLnN1YihyJygvKVwxKycsIHInXDEnLHNlbGYuc2VsZi53b3JrZGlyKQoKICAgIGRlZiBlZGl0KHNlbGYpOgogICAgICAgIGlmICJFbmFibGVkIiBpbiBzZWxmLnNlbGYuU3RhdHVzKCk6CiAgICAgICAgICAgIHNoZWxsX2NvbW1hbmQoW29zLmdldGVudigiRURJVE9SIiwidmkiKSxmIntST09UfS97c2VsZi5zZWxmLm5hbWV9L3tzZWxmLm5hbWV9LnB5Il0sc3Rkb3V0PU5vbmUpCiAgICAgICAgZWxzZToKICAgICAgICAgICAgc2hlbGxfY29tbWFuZChbb3MuZ2V0ZW52KCJFRElUT1IiLCJ2aSIpLGYie1JPT1R9L3tzZWxmLnNlbGYubmFtZX0vLntzZWxmLm5hbWV9LnB5Il0sc3Rkb3V0PU5vbmUpCgogICAgZGVmIHN0YXR1cyhzZWxmKToKICAgICAgICBzdGF0dXM9W10KICAgICAgICBpZiBvcy5wYXRoLmlzZmlsZShmIntURU1QRElSfS97c2VsZi5uYW1lfV97c2VsZi5zZWxmLm5hbWV9LmxvZyIpOgogICAgICAgICAgICBzdGF0dXMrPVsiU3RhcnRlZCJdCiAgICAgICAgZWxzZToKICAgICAgICAgICAgc3RhdHVzKz1bIlN0b3BwZWQiXQogICAgICAgIAogICAgICAgIGlmIG9zLnBhdGguZXhpc3RzKGYie1JPT1R9L3tzZWxmLnNlbGYubmFtZX0ve3NlbGYubmFtZX0ucHkiKToKICAgICAgICAgICAgc3RhdHVzKz1bIkVuYWJsZWQiXQogICAgICAgIGVsc2U6CiAgICAgICAgICAgIHN0YXR1cys9WyJEaXNhYmxlZCJdCiAgICAgICAgcmV0dXJuIHN0YXR1cwogICAgCiAgICBkZWYgZW5hYmxlKHNlbGYpOgogICAgICAgIGlmICJFbmFibGVkIiBpbiBzZWxmLnNlbGYuU3RhdHVzKCk6CiAgICAgICAgICAgIHJldHVybiBbZiJ7c2VsZi5uYW1lfSBpcyBhbHJlYWR5IGVuYWJsZWQiXQogICAgICAgIGVsc2U6CiAgICAgICAgICAgIG9zLnJlbmFtZShmIntST09UfS97c2VsZi5zZWxmLm5hbWV9Ly57c2VsZi5uYW1lfS5weSIsZiJ7Uk9PVH0ve3NlbGYuc2VsZi5uYW1lfS97c2VsZi5uYW1lfS5weSIpCiAgICAgICAgCiAgICAgICAgaWYgJy0tbm93JyBpbiBzZWxmLnNlbGYuZmxhZ3M6CiAgICAgICAgICAgIHJldHVybiBbc2VsZi5zZWxmLlN0YXJ0KCldCgogICAgZGVmIGxvb3Aoc2VsZixjb21tYW5kLGRlbGF5PTYwKToKICAgICAgICBpZiBpc2luc3RhbmNlKGNvbW1hbmQsc3RyKToKICAgICAgICAgICAgZGVmIGZ1bmMoKToKICAgICAgICAgICAgICAgIHdoaWxlIFRydWU6CiAgICAgICAgICAgICAgICAgICAgc2VsZi5zZWxmLlJ1bihjb21tYW5kKQogICAgICAgICAgICAgICAgICAgIHNlbGYuc2VsZi5XYWl0KGRlbGF5KQogICAgICAgIGVsc2U6CiAgICAgICAgICAgIGRlZiBmdW5jKCk6CiAgICAgICAgICAgICAgICB3aGlsZSBUcnVlOiAgCiAgICAgICAgICAgICAgICAgICAgY29tbWFuZCgpCiAgICAgICAgICAgICAgICAgICAgc2VsZi5zZWxmLldhaXQoZGVsYXkpCiAgICAgICAgc2VsZi5zZWxmLlJ1bigiIikgI05lZWRlZCB0byBhdm9pZCByYWNlIGNvbmRpdGlvbnMgd2l0aCBhIHJhY2UgdGhhdCdzIHJpZ2h0IGFmdGVyIC0tLSBqdXN0IHJ1biBzZWxmLnNlbGYuUnVuIG9uY2UKICAgICAgICB0aHJlYWRpbmcuVGhyZWFkKHRhcmdldD1mdW5jLGRhZW1vbj1UcnVlKS5zdGFydCgpCiAgICAgICAKICAgIGRlZiBkaXNhYmxlKHNlbGYpOgogICAgICAgIGlmICJEaXNhYmxlZCIgaW4gc2VsZi5zZWxmLlN0YXR1cygpOgogICAgICAgICAgICByZXR1cm4gW2Yie3NlbGYuc2VsZi5uYW1lfSBpcyBhbHJlYWR5IGRpc2FibGVkIl0KICAgICAgICBlbHNlOgogICAgICAgICAgICBvcy5yZW5hbWUoZiJ7Uk9PVH0ve3NlbGYuc2VsZi5uYW1lfS97c2VsZi5uYW1lfS5weSIsZiJ7Uk9PVH0ve3NlbGYuc2VsZi5uYW1lfS8ue3NlbGYubmFtZX0ucHkiKQogICAgICAgIAogICAgICAgIGlmICctLW5vdycgaW4gc2VsZi5zZWxmLmZsYWdzOgogICAgICAgICAgICByZXR1cm4gW3NlbGYuc2VsZi5TdG9wKCldCgogICAgZGVmIGxvZyhzZWxmKToKICAgICAgICBzaGVsbF9jb21tYW5kKFsibGVzcyIsIitHIiwiLWYiLCItciIsZiJ7VEVNUERJUn0ve3NlbGYubmFtZX1fe3NlbGYuc2VsZi5uYW1lfS5sb2ciXSxzdGRvdXQ9Tm9uZSkKICAgIAogICAgZGVmIGRlbGV0ZShzZWxmKToKICAgICAgICBzZWxmLnNlbGYuU3RvcCgpCiAgICAgICAgc2h1dGlsLnJtdHJlZShmIntST09UfS97c2VsZi5zZWxmLm5hbWV9IikKICAgIAogICAgZGVmIHdhdGNoKHNlbGYpOgogICAgICAgIHNoZWxsX2NvbW1hbmQoWyJ0YWlsIiwiLWYiLCItLWZvbGxvdz1uYW1lIixmIntURU1QRElSfS97c2VsZi5uYW1lfV97c2VsZi5zZWxmLm5hbWV9LmxvZyJdLHN0ZG91dD1Ob25lKQogICAgCgo=').decode("utf-8"),utils_module.__dict__)
sys.modules["utils"]=utils_module

import utils

CLASS_NAME="Service"
utils.ROOT=ROOT=utils.get_root_directory(CLASS_NAME)
utils.TEMPDIR=TEMPDIR=utils.get_tempdir()

NAMES,FLAGS,FUNCTION=utils.extract_arguments()

utils.NAMES=NAMES
utils.ROOT=ROOT
utils.GLOBALS=globals()

SHELL=os.getenv('SHELL','bash')
SHELL_CWD=os.environ.get("PWD")

def list_services(*args, **kwargs):
    return utils.list_items_in_root(*args, FLAGS,CLASS_NAME,**kwargs)    

def flatten(*args, **kwargs):
    return utils.flatten_list(*args, **kwargs)

def print_result(*args, **kwargs):
    return utils.print_list(*args, **kwargs)

def split_by_char(*args, **kwargs):
    return utils.split_by_char(*args, **kwargs)


ServiceDoesNotExist=utils.DoesNotExist
    
class Service:
    def __init__(self,_name,_flags=None,_function=None,_env=None,_workdir='.'):
        self.Class = utils.Class(self,CLASS_NAME.lower())
        self.Class.class_init(_name,_flags,_function,_workdir)
        
        self.env=utils.get_value(_env,f"export SERVICE_NAME={self.name}")
        
        self.temp_services=[]
    
    #Functions to be used in *service.py
    def Run(self,command="",pipe=False,track=True):
        with open(f"{TEMPDIR}/service_{self.name}.log","a+") as log_file:
            log_file.write(f"Command: {command}\n")
            log_file.flush()

            #Pipe output to variable
            if pipe:
                stdout=subprocess.PIPE
                stderr=subprocess.DEVNULL
            #Print output to file
            else:
                stdout=log_file
                stderr=subprocess.STDOUT
            return utils.shell_command(f"{self.env if track else 'true'}; cd {self.workdir}; {command}",stdout=stdout,stderr=stderr,arbitrary=True)
    
    def Ps(self,process=None):
        
        #Find main process
        if process=="main" or ("--main" in self.flags):
            return self.Class.get_main_process()
            
        #Find processes running under main Start script
        elif process=="auxiliary" or ("--auxiliary" in self.flags):
            processes=utils.shell_command(["ps","auxwwe"]).splitlines()
            processes=[_.split()[1] for _ in processes if f"SERVICE_NAME={self.name}" in _]
            return list(map(int,processes))

    
    def Env(self,*args, **kwargs):
        self.env=utils.add_environment_variable_to_string(self.env,*args, **kwargs)
    
    def Container(self,_container=None):
        #Convience --- if conainer name is not specified, it will assume that the container is the same name as the service
        
        if not _container:
            _container=self.name
            
        self.Down(f"container stop {_container}")
        self.Run(f"container start {_container}",track=False)
        
        
        with open(f"{TEMPDIR}/service_{self.name}.log","a+") as f:
            utils.shell_command(["tail","-f","-n","+1",f"{TEMPDIR}/container_{_container}.log"],stdout=f,block=False,env=os.environ.copy().update({"SERVICE_NAME":self.name}))
        
        container_main_pid=utils.shell_command(["container","ps","--main",_container],stdout=subprocess.PIPE)
        
        #Wait until container ends
        try:
            container_main_pid=int(container_main_pid)
            utils.wait_until_pid_exits(container_main_pid)
        except ValueError:
            pass
    
    def Down(self,func):
        #Yes, this decorator stuff is absolutely neccessary, anything else will not work
    
        if isinstance(func,str):
            #So func won't be overwritten
            func_str=func
            def func():
                utils.shell_command(func_str,arbitrary=True)
        def decorator_Exit(exit_func,func):
            def new_Exit(*args, **kwargs):
                exit_func(*args, **kwargs)
                func()
            return new_Exit
        self.Exit=decorator_Exit(self.Exit,func)
        
        #Kill all auxiliary processes when exiting
        def Exit_add_on():
            for pid in self.Ps("auxiliary"):
                utils.kill_process_gracefully(pid)
            exit()
        signal.signal(signal.SIGTERM,decorator_Exit(self.Exit,Exit_add_on))
        
    def Loop(self,*args, **kwargs):
        self.Class.loop(*args, **kwargs)
        #Run(f'(while true; do "{command}"; sleep {delay}; done)')

    def Wait(self,*args, **kwargs):
        utils.wait(*args, **kwargs)
    
    def Exit(self,signum,frame):
        pass
    
    def Dependency(self,service):
        if "Stopped" in utils.shell_command(["service","status",service]):
            #self.temp_services.append(service)
            #Kill service when stopping
            self.Down(lambda : utils.shell_command(["service","stop",service]))
            #utils.shell_command(["service","start",service])
            self.Run(f"service start {service}",track=False)
    #Commands      
    def Start(self):
        
        if "Started" in self.Status():
            return f"Service {self.name} is already started"
        
        if os.path.exists("data"):
            os.chdir("data")
        
        if "Enabled" in self.Status():
            service_file="service.py"
        else:
            service_file=".service.py"
        
        #Fork process, so it can run in the background
        pid=os.fork()
        
        #If child, run code, then exit 
        if pid==0:
            
            #Have a lambda that does nothing to make sure the SIGTERM handler is added right
            self.Down(lambda : None)
            
            #Open a lock file so I can find it with lsof later
            lock_file=open(f"{TEMPDIR}/service_{self.name}.lock","w+")
            
            #Run *service.py
            with open(f"{ROOT}/{self.name}/{service_file}") as f:
                code=f.read()
            exec(code,globals(),locals())
            
            #Don't exit script yet.
            self.Wait()
            exit()
       
    def Stop(self):
        return [self.Class.stop()]
        
    def Restart(self):
        return self.Class.restart()
    
    
    def List(self):
        return self.Class.list()
    
    def Workdir(self,work_dir):
        self.Class.workdir(work_dir)

    def Init(self):
        os.makedirs(f"{ROOT}/{self.name}",exist_ok=True)
        os.chdir(f"{ROOT}/{self.name}")
        os.makedirs("data",exist_ok=True)
        with open(f".{CLASS_NAME.lower()}.py",'a'):
            pass
        
        if '--no-edit' not in self.flags:
            self.Edit()

    def Edit(self):
        self.Class.edit()
    def Status(self):
        return self.Class.status()
    
    def Enable(self):
        return self.Class.enable()

            
    def Disable(self):
        return self.Class.disable()

    def Log(self):
        self.Class.log()
    
    def Delete(self):
        self.Class.delete()
    
    def Watch(self):
        self.Class.watch()


NAMES=list_services(NAMES)
for name in NAMES: 
    try:
        service=Service(name,FLAGS,FUNCTION)
    except ServiceDoesNotExist:
        print(f"Service {name} does not exist")
        continue
    
    utils.export_methods_globally(CLASS_NAME)
    
    result=utils.execute_class_method(eval(f"{CLASS_NAME.lower()}"),FUNCTION)
    print_result(result)
        

    
