#!/usr/bin/env python


import types
import sys
import base64
utils_module=types.ModuleType("utils")
#setattr(utils_module,"__file__",__file__)
exec(base64.b64decode(b'aW1wb3J0IHN1YnByb2Nlc3MKaW1wb3J0IHJlCmltcG9ydCB0ZW1wZmlsZQppbXBvcnQgb3MKaW1wb3J0IHBhdGhsaWIKaW1wb3J0IHNpZ25hbCAKaW1wb3J0IHRpbWUKaW1wb3J0IHN5cwppbXBvcnQgdHlwaW5nCmltcG9ydCBzaHV0aWwKaW1wb3J0IHRocmVhZGluZwppbXBvcnQgY29udGV4dGxpYgppbXBvcnQgd2FybmluZ3MKaW1wb3J0IHRyYWNlYmFjawoKZm9yIHZhciBpbiBbIlJPT1QiLCJHTE9CQUxTIiwiQ0xBU1MiLCJnZXRfYWxsX2l0ZW1zIl06CiAgICBnbG9iYWxzKClbdmFyXT1Ob25lCiAgICAKZGVmIGdldF90ZW1wZGlyKCk6CiAgICBpZiBvcy51bmFtZSgpLnN5c25hbWU9PSJEYXJ3aW4iOgogICAgICAgIHJldHVybiAiL3RtcCIKICAgIGVsc2U6CiAgICAgICAgcmV0dXJuIHRlbXBmaWxlLmdldHRlbXBkaXIoKQogICAgCmNsYXNzIERvZXNOb3RFeGlzdChFeGNlcHRpb24pOgogICAgcGFzcwoKZGVmIGdldF92YWx1ZSh2YXJpYWJsZSxkZWZhdWx0KToKCWlmIG5vdCB2YXJpYWJsZToKCQlyZXR1cm4gZGVmYXVsdAoJZWxzZToKCQlyZXR1cm4gdmFyaWFibGUKCmRlZiBnZXRfcm9vdF9kaXJlY3Rvcnkocm9vdF92YXJpYWJsZT1Ob25lLGRlZmF1bHRfdmFsdWU9Tm9uZSk6CiAgICByb290X3ZhcmlhYmxlPWdldF92YWx1ZShyb290X3ZhcmlhYmxlLGYie0NMQVNTLl9fbmFtZV9fLnVwcGVyKCl9X1JPT1QiKQogICAgZGVmYXVsdF92YWx1ZT1nZXRfdmFsdWUoZGVmYXVsdF92YWx1ZSxmIntvcy5lbnZpcm9uWydIT01FJ119L3tDTEFTUy5fX25hbWVfXy50aXRsZSgpfXMiKQogICAgcmV0dXJuIG9zLnBhdGguZXhwYW5kdXNlcihvcy5nZXRlbnYocm9vdF92YXJpYWJsZSxkZWZhdWx0X3ZhbHVlKSkKCgpkZWYgbGlzdF9pdGVtc19pbl9yb290KG5hbWVzLGZsYWdzKToKICAgIGdsb2JhbCBnZXRfYWxsX2l0ZW1zCiAgICBpZiBub3QgZ2V0X2FsbF9pdGVtczoKICAgICAgICBnZXRfYWxsX2l0ZW1zID0gbGFtYmRhIHJvb3Q6IFtfIGZvciBfIGluIHNvcnRlZChvcy5saXN0ZGlyKHJvb3QgKSkgaWYgbm90IF8uc3RhcnRzd2l0aCgnLicpIF0gI0ZhbGwgYmFjayB0byBkZWZhdWx0IGlmIG5vIHNwZWNpYWwgZnVuY3Rpb24gaXMgZGVmaW5lZAogICAgICAgIAogICAgQWxsPWdldF9hbGxfaXRlbXMoUk9PVCkKICAgICNBbGw9W18gZm9yIF8gaW4gc29ydGVkKG9zLmxpc3RkaXIoUk9PVCkpIGlmIG5vdCBfLnN0YXJ0c3dpdGgoJy4nKSBdCiAgICAKICAgIGZvciBmbGFnIGluIFsic3RhcnRlZCIsInN0b3BwZWQiLCJlbmFibGVkIiwiZGlzYWJsZWQiXToKICAgICAgICBpZiBmbGFnIGluIGZsYWdzOgogICAgICAgICAgICBuYW1lcys9W18gZm9yIF8gaW4gQWxsIGlmIGZsYWcudGl0bGUoKSBpbiBDTEFTUyhfKS5TdGF0dXMoKSBdCiAgICAgICAgICAgIGRlbCBmbGFnc1tmbGFnXQoKICAgIGlmICJhbGwiIGluIGZsYWdzOgogICAgICAgIG5hbWVzKz1BbGwKICAgICAgICBkZWwgZmxhZ3NbImFsbCJdCiAgICBpZiBuYW1lcz09W106CiAgICAgICAgcHJpbnQoZiJObyB7Q0xBU1MuX19uYW1lX18ubG93ZXIoKX1zIHNwZWNpZmllZCEiKQogICAgICAgIGV4aXQoKQogICAgcmV0dXJuIG5hbWVzCgpkZWYgZmxhdHRlbl9saXN0KGl0ZW1zKToKICAgICIiIllpZWxkIGl0ZW1zIGZyb20gYW55IG5lc3RlZCBpdGVyYWJsZS4iIiIKICAgIGZvciB4IGluIGl0ZW1zOgogICAgICAgIGlmIGlzaW5zdGFuY2UoeCwgdHlwaW5nLkl0ZXJhYmxlKSBhbmQgbm90IGlzaW5zdGFuY2UoeCwgKHN0ciwgYnl0ZXMpKToKICAgICAgICAgICAgZm9yIHN1Yl94IGluIGZsYXR0ZW5fbGlzdCh4KToKICAgICAgICAgICAgICAgIHlpZWxkIHN1Yl94CiAgICAgICAgZWxzZToKICAgICAgICAgICAgeWllbGQgeAoKZGVmIHByaW50X2xpc3QobCk6CiAgICBmb3IgZWxlbWVudCBpbiBsOgogICAgICAgIGlmIGVsZW1lbnQgaXMgTm9uZToKICAgICAgICAgICAgcHJpbnQoZW5kPScnKQogICAgICAgIGVsc2U6CiAgICAgICAgICAgIHByaW50KGVsZW1lbnQpCgpkZWYgc3BsaXRfc3RyaW5nX2J5X2NoYXIoc3RyaW5nLGNoYXI9JzonKToKICAgIFBBVFRFUk4gPSByZS5jb21waWxlKHJmJycnKCg/OlteXHtjaGFyfSInXXwiW14iXSoifCdbXiddKicpKyknJycpCiAgICByZXR1cm4gW18gZm9yIF8gaW4gbGlzdChQQVRURVJOLnNwbGl0KHN0cmluZykpIGlmIF8gbm90IGluIFsnJywgY2hhcl1dCgoKZGVmIHNoZWxsX2NvbW1hbmQoY29tbWFuZCxzdGRvdXQ9c3VicHJvY2Vzcy5QSVBFLHN0ZGVycj1zdWJwcm9jZXNzLlNURE9VVCxhcmJpdHJhcnk9RmFsc2UsYmxvY2s9VHJ1ZSxlbnY9Tm9uZSk6CiAgICBwcm9jZXNzID0gc3VicHJvY2Vzcy5Qb3Blbihjb21tYW5kLCBzdGRvdXQ9c3Rkb3V0LCBzdGRlcnI9c3RkZXJyLHVuaXZlcnNhbF9uZXdsaW5lcz1UcnVlLHNoZWxsPWFyYml0cmFyeSxlbnY9ZW52KQogICAgaWYgYmxvY2s6CiAgICAgICAgcmV0dXJuIHByb2Nlc3MuY29tbXVuaWNhdGUoKVswXQoKZGVmIHdhaXRfdW50aWxfcGlkX2V4aXRzKHBpZCk6CiAgICAKICAgIGRlZiBwaWRfZXhpc3RzKHBpZCk6ICAgCiAgICAgICAgIiIiIENoZWNrIEZvciB0aGUgZXhpc3RlbmNlIG9mIGEgdW5peCBwaWQuICIiIgogICAgICAgIGlmIHNoZWxsX2NvbW1hbmQoWyJwcyIsICItb3N0YXQ9IixzdHIocGlkKV0pPT0iWlxuIjogI1pvbWJpZQogICAgICAgIAogICAgICAgICAgICByZXR1cm4gRmFsc2UgCiAgICAgICAgdHJ5OgogICAgICAgICAgICBvcy5raWxsKHBpZCwgMCkKICAgICAgICBleGNlcHQgT1NFcnJvcjoKICAgICAgICAgICAgcmV0dXJuIEZhbHNlCiAgICAgICAgZWxzZToKICAgICAgICAgICAgcmV0dXJuIFRydWUKICAgICAgICAgICAgCiAgICB3aGlsZSBwaWRfZXhpc3RzKHBpZCk6CiAgICAgICAgdGltZS5zbGVlcCgwLjI1KQogICAgICAgIApkZWYga2lsbF9wcm9jZXNzX2dyYWNlZnVsbHkocGlkKToKICAgIHByaW50KHBpZCkKICAgIHRyeToKICAgICAgICBvcy5raWxsKHBpZCxzaWduYWwuU0lHVEVSTSkKICAgICAgICB0cnk6CiAgICAgICAgICAgIG9zLndhaXRwaWQocGlkLDApCiAgICAgICAgZXhjZXB0IENoaWxkUHJvY2Vzc0Vycm9yOiAjTm90IGEgY2hpbGQgcHJvY2VzcyBzbyBtb3ZlIG9uCiAgICAgICAgICAgIHBhc3MKICAgICAgICB3YWl0X3VudGlsX3BpZF9leGl0cyhwaWQpCiAgICBleGNlcHQgUHJvY2Vzc0xvb2t1cEVycm9yOgogICAgICAgIHBhc3MKICAgIApkZWYgZXh0cmFjdF9hcmd1bWVudHMoKToKICAgIGFyZ3VtZW50cz1zeXMuYXJndlsxOl0KICAgIHRyeToKICAgICAgICBGVU5DVElPTj1hcmd1bWVudHNbMF0KICAgIGV4Y2VwdCBJbmRleEVycm9yOgogICAgICAgIHByaW50KCJObyBmdW5jdGlvbiBzcGVjaWZpZWQhIikKICAgICAgICBleGl0KCkKICAgIGFyZ3VtZW50cz1hcmd1bWVudHNbMTpdCiAgICAKICAgIE5BTUVTPVtdCiAgICBGTEFHUz1hcmd1bWVudHMKICAgIGZvciBpIGluIHJhbmdlKGxlbihhcmd1bWVudHMpKToKICAgICAgICBpZiBub3QgYXJndW1lbnRzW2ldLnN0YXJ0c3dpdGgoIi0tIik6CiAgICAgICAgICAgIEZMQUdTPWFyZ3VtZW50c1s6aV0KICAgICAgICAgICAgTkFNRVM9YXJndW1lbnRzW2k6XQogICAgICAgICAgICBicmVhawogICAgICAgICAgICAKICAgIGZsYWdzX3RlbXA9e30KICAgIGZvciBmbGFnIGluIEZMQUdTOgogICAgICAgIGZsYWc9ZmxhZy5zcGxpdCgnPScsMSkgI1NwbGl0IGV2ZXJ5IGZsYWcgaW4gRkxBR1MgYnkgJz0nCiAgICAgICAgaWYgbGVuKGZsYWcpPT0xOgogICAgICAgICAgICBmbGFnLmFwcGVuZCgnJykgI1BhZCBvdXQgdGhlIGZsYWcgYXJyYXkKICAgICAgICBmbGFnWzBdPWZsYWdbMF1bMjpdICNSZW1vdmUgdGhlICctLScKICAgICAgICBmbGFnc190ZW1wW2ZsYWdbMF1dPWZsYWdbMV0KICAgICAgICAKICAgIEZMQUdTPWZsYWdzX3RlbXAKICAgIHJldHVybiAoTkFNRVMsRkxBR1MsRlVOQ1RJT04pCgpkZWYgYWRkX2Vudmlyb25tZW50X3ZhcmlhYmxlX3RvX3N0cmluZyhzdHJpbmcsZW52X3Zhcik6CiAgICByZXR1cm4gc3RyaW5nK2YiOyBleHBvcnQge2Vudl92YXJ9IgoKZGVmIHdhaXQoZGVsYXk9Tm9uZSk6CiAgICB0aHJlYWRpbmcuRXZlbnQoKS53YWl0KHRpbWVvdXQ9ZGVsYXkpCgpkZWYgZXhlY3V0ZV9jbGFzc19tZXRob2QoY2xhc3NfaW5zdGFuY2UsZnVuY3Rpb24pOgogICAgaWYgbm90IGNhbGxhYmxlKGdldGF0dHIoY2xhc3NfaW5zdGFuY2UsIGZ1bmN0aW9uLnRpdGxlKCksTm9uZSkpOgogICAgICAgICAgICBwcmludChmIkNvbW1hbmQge2Z1bmN0aW9ufSBkb2Vzbid0IGV4aXN0ISIpCiAgICAgICAgICAgIGV4aXQoKQogICAgZWxzZToKICAgICAgICByZXR1cm4gbGlzdChmbGF0dGVuX2xpc3QoW2dldGF0dHIoY2xhc3NfaW5zdGFuY2UsZnVuY3Rpb24udGl0bGUoKSkoKV0pKQoKZGVmIGNoZWNrX2lmX2VsZW1lbnRfYW55X2lzX2luX2xpc3QoZWxlbWVudHMsX2xpc3QpOgogICAgcmV0dXJuIGFueShfIGluIF9saXN0IGZvciBfIGluIGVsZW1lbnRzKQogICAgCmRlZiBleHBvcnRfbWV0aG9kc19mcm9tX3NlbGYoc2VsZik6CiAgICBtZXRob2RzPXt9CiAgICBmb3IgZnVuYyBpbiBbZnVuYyBmb3IgZnVuYyBpbiBkaXIoc2VsZikgaWYgY2FsbGFibGUoZ2V0YXR0cihzZWxmLCBmdW5jKSkgYW5kIG5vdCBmdW5jLnN0YXJ0c3dpdGgoJ19fJyldOgogICAgICAgIGlmIG5vdCBmdW5jLnN0YXJ0c3dpdGgoJ18nKToKICAgICAgICAgICAgbWV0aG9kc1tmdW5jXT1nZXRhdHRyKHNlbGYsZnVuYykKICAgIAogICAgcmV0dXJuIG1ldGhvZHMKCmRlZiBleGVjdXRlKHNlbGYsZmlsZSk6CiAgICB0cnk6CiAgICAgICAgaWYgbm90IGlzaW5zdGFuY2UoZmlsZSxzdHIpOiAjQXNzdW1lIGZpbGUgaXMgZmlsZSBvYmplY3QKICAgICAgICAgICAgY29kZT1maWxlLnJlYWQoKQogICAgICAgICAgICBmaWxlLmNsb3NlKCkKICAgICAgICBlbHNlOgogICAgICAgICAgICBjb2RlPWZpbGUKICAgICAgICByZXR1cm4gZXhlYyhjb2RlLHNlbGYuZ2xvYmFscyxsb2NhbHMoKSkKICAgIGV4Y2VwdCBTeXN0ZW1FeGl0IGFzIGU6CiAgICAgICAgZXhpdChlKQogICAgZXhjZXB0OgogICAgICAgIHRyYWNlYmFjay5wcmludF9leGMoKQogICAgICAgIHNlbGYuU3RvcCgpCiAgICAgICAgICAgIApkZWYgd3JhcF9hbGxfbWV0aG9kc19pbl9jbGFzc193aXRoX2NoZGlyX2NvbnRleHRtYW5hZ2VyKHNlbGYscGF0aCk6CiAgICBAY29udGV4dGxpYi5jb250ZXh0bWFuYWdlcgogICAgZGVmIHNldF9kaXJlY3RvcnkocGF0aCk6CiAgICAgICAgIiIiU2V0cyB0aGUgY3dkIHdpdGhpbiB0aGUgY29udGV4dAogICAgCiAgICAgICAgQXJnczoKICAgICAgICAgICAgcGF0aCAoUGF0aCk6IFRoZSBwYXRoIHRvIHRoZSBjd2QKICAgIAogICAgICAgIFlpZWxkczoKICAgICAgICAgICAgTm9uZQogICAgICAgICIiIgogICAgCiAgICAgICAgb3JpZ2luID0gb3MucGF0aC5hYnNwYXRoKG9zLmdldGN3ZCgpKQogICAgICAgIHRyeToKICAgICAgICAgICAgaWYgb3MucGF0aC5pc2RpcihwYXRoKToKICAgICAgICAgICAgICAgIG9zLmNoZGlyKHBhdGgpCiAgICAgICAgICAgIHlpZWxkCiAgICAgICAgZmluYWxseToKICAgICAgICAgICAgICAgIG9zLmNoZGlyKG9yaWdpbikKICAgIAogICAgZGVmIHdyYXBwZXIoZnVuYyk6CiAgICAgICAgZGVmIG5ld19mdW5jKCphcmdzLCAqKmt3YXJncyk6CiAgICAgICAgICAgIHdpdGggc2V0X2RpcmVjdG9yeShwYXRoKToKICAgICAgICAgICAgICAgIHJldHVybiBmdW5jKCphcmdzLCAqKmt3YXJncykKICAgICAgICByZXR1cm4gbmV3X2Z1bmMKICAgICAgICAgICAgCiAgICBmb3IgZnVuYyBpbiBbZnVuYyBmb3IgZnVuYyBpbiBkaXIoc2VsZikgaWYgY2FsbGFibGUoZ2V0YXR0cihzZWxmLCBmdW5jKSkgYW5kIG5vdCBmdW5jLnN0YXJ0c3dpdGgoJ19fJyldOgogICAgICAgIHNldGF0dHIoc2VsZixmdW5jLHdyYXBwZXIoZ2V0YXR0cihzZWxmLGZ1bmMpKSkKY2xhc3MgQ2xhc3M6CiAgICBkZWYgX19pbml0X18oc2VsZixjbGFzc19zZWxmLF9uYW1lLF9mbGFncyxfd29ya2Rpcik6CiAgICAgICAgc2VsZi5zZWxmPWNsYXNzX3NlbGYKICAgICAgICBzZWxmLm5hbWU9Q0xBU1MuX19uYW1lX18KICAgICAgICAKICAgICAgICBzZWxmLnNlbGYubmFtZT1fbmFtZQogICAgICAgIAogICAgICAgIHNlbGYuc2VsZi5mbGFncz1nZXRfdmFsdWUoX2ZsYWdzLHt9KQogICAgICAgIAojICAgICAgICBpZiBub3Qgb3MucGF0aC5pc2RpcihmIntST09UfS97c2VsZi5zZWxmLm5hbWV9Iik6CiMgICAgICAgICAgICAgcmFpc2UgRG9lc05vdEV4aXN0KCkKIyAgICAgICAgICAgICByZXR1cm4KICAgICAgICAgICAgIAogICAgICAgIHNlbGYuc2VsZi50ZW1wPW9zLnBhdGguam9pbihnZXRfdGVtcGRpcigpLHNlbGYubmFtZS50aXRsZSgpKyJzIixzZWxmLnNlbGYubmFtZSkKICAgICAgICBzZWxmLnNlbGYubG9nPW9zLnBhdGguam9pbihzZWxmLnNlbGYudGVtcCwibG9nIikKICAgICAgICBzZWxmLnNlbGYubG9jaz1vcy5wYXRoLmpvaW4oc2VsZi5zZWxmLnRlbXAsImxvY2siKQogICAgICAgIAogICAgICAgIG9zLm1ha2VkaXJzKHNlbGYuc2VsZi50ZW1wLGV4aXN0X29rPVRydWUpCiAgICAgICAgCiAgICAgICAgd3JhcF9hbGxfbWV0aG9kc19pbl9jbGFzc193aXRoX2NoZGlyX2NvbnRleHRtYW5hZ2VyKHNlbGYuc2VsZixmIntST09UfS97c2VsZi5zZWxmLm5hbWV9IikKICAgICAgICBzZWxmLnNlbGYud29ya2Rpcj1fd29ya2RpcgogICAgICAgIAogICAgICAgIHNlbGYuc2VsZi5nbG9iYWxzPUdMT0JBTFMuY29weSgpCiAgICAgICAgc2VsZi5zZWxmLmdsb2JhbHMudXBkYXRlKGV4cG9ydF9tZXRob2RzX2Zyb21fc2VsZihzZWxmLnNlbGYpKQogICAgICAgIAogICAgICAgIAogICAgZGVmIHN0b3Aoc2VsZik6CiAgICAgICAgaWYgIlN0b3BwZWQiIGluIHNlbGYuc2VsZi5TdGF0dXMoKToKICAgICAgICAgICAgcmV0dXJuIGYie3NlbGYubmFtZX0ge3NlbGYuc2VsZi5uYW1lfSBpcyBhbHJlYWR5IHN0b3BwZWQiCiAgICAgICAgCiAgICAgICAgZm9yIHBpZCBpbiBzZWxmLnNlbGYuUHMoIm1haW4iKToKICAgICAgICAgICAga2lsbF9wcm9jZXNzX2dyYWNlZnVsbHkocGlkKQogICAgICAgIAogICAgICAgIGZvciBmaWxlIGluIFsibG9nIiwibG9jayJdOgogICAgICAgICAgICB0cnk6CiAgICAgICAgICAgICAgIG9zLnJlbW92ZShnZXRhdHRyKHNlbGYuc2VsZixmaWxlKSkKICAgICAgICAgICAgZXhjZXB0IEZpbGVOb3RGb3VuZEVycm9yOgogICAgICAgICAgICAgICAgcGFzcwoKICAgIGRlZiByZXN0YXJ0KHNlbGYpOgogICAgICAgIHJldHVybiBbc2VsZi5zZWxmLlN0b3AoKSxzZWxmLnNlbGYuU3RhcnQoKV0KICAgIAogICAgZGVmIGdldF9tYWluX3Byb2Nlc3Moc2VsZik6CiAgICAgICAgaWYgbm90IG9zLnBhdGguaXNmaWxlKHNlbGYuc2VsZi5sb2NrKToKICAgICAgICAgICAgICAgIHJldHVybiBbXQogICAgICAgIGVsc2U6CiAgICAgICAgICAgIHJldHVybiBsaXN0KG1hcChpbnQsW18gZm9yIF8gaW4gc2hlbGxfY29tbWFuZChbImxzb2YiLCItdCIsIi13IixzZWxmLnNlbGYubG9ja10pLnNwbGl0bGluZXMoKV0pKQogICAgCiAgICBkZWYgbGlzdChzZWxmKToKICAgICAgICByZXR1cm4gc2VsZi5zZWxmLm5hbWUKICAgIAogICAgICAgIAogICAgZGVmIHdvcmtkaXIoc2VsZix3b3JrX2Rpcik6CiAgICAgICAgc2VsZi5zZWxmLndvcmtkaXI9b3MucGF0aC5qb2luKHNlbGYuc2VsZi53b3JrZGlyLHdvcmtfZGlyKQogICAgICAgICNSZW1vdmUgdHJhaWxpbmcgc2xhc2hlcywgYnV0IG9ubHkgZm9yIHN0cmluZ3MgdGhhdCBhcmUgbm90IC8KICAgICAgICAjaWYgd29ya19kaXIuZW5kc3dpdGgoJy8nKSBhbmQgbGVuKHdvcmtfZGlyKT4xOgogICAgICAgICAgICAjd29ya19kaXI9d29ya19kaXJbOi0xXQogICAgICAgICAgICAjCiAgICAgICAgI2lmIHdvcmtfZGlyLnN0YXJ0c3dpdGgoIi8iKToKICAgICAgICAgICAgI3NlbGYuc2VsZi53b3JrZGlyPXdvcmtfZGlyCiAgICAgICAgI2Vsc2U6ICAgIAogICAgICAgICAgICAjc2VsZi5zZWxmLndvcmtkaXIrPScvJyt3b3JrX2RpcgogICAgICAgIAogICAgICAgICNSZW1vdmUgcmVwZWF0ZWQgLyBpbiB3b3JrZGlyCiAgICAgICAgI3NlbGYuc2VsZi53b3JrZGlyPXJlLnN1YihyJygvKVwxKycsIHInXDEnLHNlbGYuc2VsZi53b3JrZGlyKQoKICAgIGRlZiBzdGF0dXMoc2VsZik6CiAgICAgICAgaWYgb3MucGF0aC5pc2ZpbGUoc2VsZi5zZWxmLmxvZyk6CiAgICAgICAgICAgIHJldHVybiBbIlN0YXJ0ZWQiXQogICAgICAgIGVsc2U6CiAgICAgICAgICAgIHJldHVybiBbIlN0b3BwZWQiXQoKICAgIGRlZiBsb29wKHNlbGYsY29tbWFuZCxkZWxheT02MCk6CiAgICAgICAgaWYgaXNpbnN0YW5jZShjb21tYW5kLHN0cik6CiAgICAgICAgICAgIGRlZiBmdW5jKCk6CiAgICAgICAgICAgICAgICB3aGlsZSBUcnVlOgogICAgICAgICAgICAgICAgICAgIHNlbGYuc2VsZi5SdW4oY29tbWFuZCkKICAgICAgICAgICAgICAgICAgICBzZWxmLnNlbGYuV2FpdChkZWxheSkKICAgICAgICBlbHNlOgogICAgICAgICAgICBkZWYgZnVuYygpOgogICAgICAgICAgICAgICAgd2hpbGUgVHJ1ZTogIAogICAgICAgICAgICAgICAgICAgIGNvbW1hbmQoKQogICAgICAgICAgICAgICAgICAgIHNlbGYuc2VsZi5XYWl0KGRlbGF5KQogICAgICAgIHNlbGYuc2VsZi5SdW4oIiIpICNOZWVkZWQgdG8gYXZvaWQgcmFjZSBjb25kaXRpb25zIHdpdGggYSByYWNlIHRoYXQncyByaWdodCBhZnRlciAtLS0ganVzdCBydW4gc2VsZi5zZWxmLlJ1biBvbmNlCiAgICAgICAgdGhyZWFkaW5nLlRocmVhZCh0YXJnZXQ9ZnVuYyxkYWVtb249VHJ1ZSkuc3RhcnQoKQogICAgICAgCiAgICBkZWYga2lsbF9hdXhpbGlhcnlfcHJvY2Vzc2VzKHNlbGYpOgogICAgICAgIHdoaWxlIHNlbGYuc2VsZi5QcygiYXV4aWxpYXJ5IikhPVtdOiAjSWYgbmV3IHByb2Nlc3NlcyB3ZXJlIHN0YXJ0ZWQgZHVyaW5nIGFuIGl0ZXJhdGlvbiwgZ28gb3ZlciBpdCBhZ2FpbiwgdW50aWwgeW91IGtpbGxlZCB0aGVtIGFsbAogICAgICAgICAgICBmb3IgcGlkIGluIHNlbGYuc2VsZi5QcygiYXV4aWxpYXJ5Iik6CiAgICAgICAgICAgICAgICBraWxsX3Byb2Nlc3NfZ3JhY2VmdWxseShwaWQpCiAgICAgICAgICAgICAgICAKICAgIGRlZiBsb2coc2VsZik6CiAgICAgICAgc2hlbGxfY29tbWFuZChbImxlc3MiLCIrRyIsIi1mIiwiLXIiLHNlbGYuc2VsZi5sb2ddLHN0ZG91dD1Ob25lKQogICAgCiAgICBkZWYgZGVsZXRlKHNlbGYpOgogICAgICAgIHNlbGYuc2VsZi5TdG9wKCkKICAgICAgICBzaHV0aWwucm10cmVlKGYie1JPT1R9L3tzZWxmLnNlbGYubmFtZX0iKQogICAgCiAgICBkZWYgd2F0Y2goc2VsZik6CiAgICAgICAgdHJ5OgogICAgICAgICAgICBzaGVsbF9jb21tYW5kKFsidGFpbCIsIi1mIiwiLS1mb2xsb3c9bmFtZSIsc2VsZi5zZWxmLmxvZ10sc3Rkb3V0PU5vbmUpCiAgICAgICAgZXhjZXB0IEtleWJvYXJkSW50ZXJydXB0OgogICAgICAgICAgICBwYXNzCiAgICAKCg==').decode("utf-8"),utils_module.__dict__)
sys.modules["utils"]=utils_module
import subprocess
import os
import signal

import utils

import importlib.machinery, shutil

utils.GLOBALS=globals()


def flatten(*args, **kwargs):
    return utils.flatten_list(*args, **kwargs)

def print_result(*args, **kwargs):
    return utils.print_list(*args, **kwargs)

def split_by_char(*args, **kwargs):
    return utils.split_by_char(*args, **kwargs)
    
class Service:
    def __init__(self,_name,_flags=None,_env=None,_workdir='.'):
        self.Class = utils.Class(self,_name,_flags,_workdir)
        
        self.env=utils.get_value(_env,f"export SERVICE_NAME={self.name}")
        
        self.temp_services=[]
        
        self.exit_cmds=[]

    #Functions to be used in *service.py
    def Run(self,command="",pipe=False,track=True):
        with open(self.log,"a+") as log_file:
            if track:
                log_file.write(f"Command: {command}\n")
                log_file.flush()

            #Pipe output to variable
            if pipe:
                stdout=subprocess.PIPE
                stderr=subprocess.DEVNULL
            #Print output to file
            else:
                stdout=log_file
                stderr=subprocess.STDOUT
            return utils.shell_command(f"{self.env if track else 'true'}; cd {self.workdir}; {command}",stdout=stdout,stderr=stderr,arbitrary=True)
    
    def Ps(self,process=None):
        
        #Find main process
        if process=="main" or ("main" in self.flags):
            return self.Class.get_main_process()
            
        #Find processes running under main Start script
        elif process=="auxiliary" or ("auxiliary" in self.flags):
            processes=utils.shell_command(["ps","auxwwe"]).splitlines()
            processes=[_.split()[1] for _ in processes if f"SERVICE_NAME={self.name}" in _]
            return list(map(int,processes))

    
    def Env(self,*args, **kwargs):
        self.env=utils.add_environment_variable_to_string(self.env,*args, **kwargs)
    
    def Container(self,_container=None):
        #Convinence --- if conainer name is not specified, it will assume that the container is the same name as the service
        container = importlib.machinery.SourceFileLoader("gfg",shutil.which("container")).load_module()
        if not _container:
            _container=self.name
        
        _container=container.Container(_container)
        self.Down(lambda : _container.Stop())
        #self.Down(f"container stop {_container}")
        
        _container.Start()
        #self.Run(f"container start {_container}",track=False)
        
        self.Run(f"echo Started container {_container.name}",track=False)
        
        with open(self.log,"a+") as f:
            utils.shell_command(["tail","-f","-n","+1",_container.log],stdout=f,block=False,env=os.environ.copy() | {"SERVICE_NAME":self.name})
        
        container_main_pid=_container.Ps("main")[0]
        #container_main_pid=utils.shell_command(["container","ps","--main",_container],stdout=subprocess.PIPE)
        
        #Wait until container ends
        try:
            container_main_pid=int(container_main_pid)
            utils.wait_until_pid_exits(container_main_pid)
        except ValueError:
            pass
    
    def Down(self,func):
        if isinstance(func,str):
            #So func won't be overwritten
            func_str=func
            def func():
                self.Run(func_str)
        self.exit_cmds.append(func)
        
    def Loop(self,*args, **kwargs):
        self.Class.loop(*args, **kwargs)
        #Run(f'(while true; do "{command}"; sleep {delay}; done)')

    def Wait(self,*args, **kwargs):
        utils.wait(*args, **kwargs)
    
    def Exit(self,signum,frame):
        for cmd in self.exit_cmds:
            cmd()
            
        self.Class.kill_auxiliary_processes()
        
        exit()
    
    def Dependency(self,service):
        if "Stopped" in self.__class__(service).Status():
            #self.temp_services.append(service)
            #Kill service when stopping
            self.Down(self.__class__(service).Stop)
            #utils.shell_command(["service","start",service],stdout=subprocess.DEVNULL)
            self.__class__(service).Start()
    #Commands      
    def Start(self):
        
        if "Started" in self.Status():
            return f"Service {self.name} is already started"
        
        #If child, run code, then exit 
        if os.fork()==0:
            signal.signal(signal.SIGTERM,self.Exit)
            
            if os.path.exists("data"):
                self.Workdir("data")
            
            if "Enabled" in self.Status():
                service_file="service.py"
            else:
                service_file=".service.py"
                
            #Open a lock file so I can find it with lsof later
            lock_file=open(self.lock,"w+")
            
            #Run *service.py
            utils.execute(self,open(f"{ROOT}/{self.name}/{service_file}"))
            
            #Don't exit script yet.
            self.Wait()
            exit()
       
    def Stop(self):
        return [self.Class.stop()]
        
    def Restart(self):
        return self.Class.restart()
    
    
    def List(self):
        return self.Class.list()
    
    def Workdir(self,work_dir):
        self.Class.workdir(work_dir)

    def Init(self):
        os.makedirs(f"{ROOT}/{self.name}",exist_ok=True)
        os.chdir(f"{ROOT}/{self.name}")
        os.makedirs("data",exist_ok=True)
        with open(f".service.py",'a'):
            pass
        
        if 'no-edit' not in self.flags:
            self.Edit()

    def Edit(self):
        if "Enabled" in self.Status():
            utils.shell_command([os.getenv("EDITOR","vi"),f"{ROOT}/{self.name}/service.py"],stdout=None)
        else:
            utils.shell_command([os.getenv("EDITOR","vi"),f"{ROOT}/{self.name}/.service.py"],stdout=None)
            
    def Status(self):
        return self.Class.status() + ["Enabled" if os.path.exists(f"{ROOT}/{self.name}/service.py") else "Disabled"]
    
    def Enable(self):
        if "Enabled" in self.Status():
            return [f"Service {self.name} is already enabled"]
        else:
            os.rename(f"{ROOT}/{self.name}/.service.py",f"{ROOT}/{self.name}/service.py")
        
        if 'now' in self.flags:
            return [self.Start()]

            
    def Disable(self):
        if "Disabled" in self.Status():
            return [f"Service {self.name} is already disabled"]
        else:
            os.rename(f"{ROOT}/{self.name}/service.py",f"{ROOT}/{self.name}/.service.py")
        
        if 'now' in self.flags:
            return [self.Stop()]

    def Log(self):
        self.Class.log()
    
    def Delete(self):
        self.Class.delete()
    
    def Watch(self):
        self.Class.watch()
utils.CLASS=Service
utils.ROOT=ROOT=utils.get_root_directory()
if __name__ == "__main__":
    
    NAMES,FLAGS,FUNCTION=utils.extract_arguments()
    
    for name in utils.list_items_in_root(NAMES, FLAGS): 
        item=utils.CLASS(name,FLAGS)
        result=utils.execute_class_method(item,FUNCTION)
        print_result(result)
        

    
