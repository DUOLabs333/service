#!/usr/bin/env python


import types
import sys
import base64
utils_module=types.ModuleType("utils")
#setattr(utils_module,"__file__",__file__)
exec(base64.b64decode(b'aW1wb3J0IHN1YnByb2Nlc3MKaW1wb3J0IHJlCmltcG9ydCB0ZW1wZmlsZQppbXBvcnQgb3MKaW1wb3J0IHBhdGhsaWIKaW1wb3J0IHNpZ25hbCAKaW1wb3J0IHRpbWUKaW1wb3J0IHN5cwppbXBvcnQgdHlwaW5nCmltcG9ydCBzaHV0aWwKaW1wb3J0IHRocmVhZGluZwppbXBvcnQgY29udGV4dGxpYgppbXBvcnQgd2FybmluZ3MKaW1wb3J0IHRyYWNlYmFjawoKZm9yIHZhciBpbiBbIlJPT1QiLCJHTE9CQUxTIiwiQ0xBU1MiLCJnZXRfYWxsX2l0ZW1zIl06CiAgICBnbG9iYWxzKClbdmFyXT1Ob25lCiAgICAKZGVmIGdldF90ZW1wZGlyKCk6CiAgICBpZiBvcy51bmFtZSgpLnN5c25hbWU9PSJEYXJ3aW4iOgogICAgICAgIHJldHVybiAiL3RtcCIKICAgIGVsc2U6CiAgICAgICAgcmV0dXJuIHRlbXBmaWxlLmdldHRlbXBkaXIoKQogICAgCmNsYXNzIERvZXNOb3RFeGlzdChFeGNlcHRpb24pOgogICAgcGFzcwoKZGVmIGdldF92YWx1ZSh2YXJpYWJsZSxkZWZhdWx0KToKCWlmIG5vdCB2YXJpYWJsZToKCQlyZXR1cm4gZGVmYXVsdAoJZWxzZToKCQlyZXR1cm4gdmFyaWFibGUKCmRlZiBnZXRfcm9vdF9kaXJlY3Rvcnkocm9vdF92YXJpYWJsZT1Ob25lLGRlZmF1bHRfdmFsdWU9Tm9uZSk6CiAgICByb290X3ZhcmlhYmxlPWdldF92YWx1ZShyb290X3ZhcmlhYmxlLGYie0NMQVNTLl9fbmFtZV9fLnVwcGVyKCl9X1JPT1QiKQogICAgZGVmYXVsdF92YWx1ZT1nZXRfdmFsdWUoZGVmYXVsdF92YWx1ZSxmIntvcy5lbnZpcm9uWydIT01FJ119L3tDTEFTUy5fX25hbWVfXy50aXRsZSgpfXMiKQogICAgcmV0dXJuIG9zLnBhdGguZXhwYW5kdXNlcihvcy5nZXRlbnYocm9vdF92YXJpYWJsZSxkZWZhdWx0X3ZhbHVlKSkKCgpkZWYgbGlzdF9pdGVtc19pbl9yb290KG5hbWVzLGZsYWdzKToKICAgIGdsb2JhbCBnZXRfYWxsX2l0ZW1zCiAgICBpZiBub3QgZ2V0X2FsbF9pdGVtczoKICAgICAgICBnZXRfYWxsX2l0ZW1zID0gbGFtYmRhIHJvb3Q6IFtfIGZvciBfIGluIHNvcnRlZChvcy5saXN0ZGlyKHJvb3QgKSkgaWYgbm90IF8uc3RhcnRzd2l0aCgnLicpIF0gI0ZhbGwgYmFjayB0byBkZWZhdWx0IGlmIG5vIHNwZWNpYWwgZnVuY3Rpb24gaXMgZGVmaW5lZAogICAgICAgIAogICAgQWxsPWdldF9hbGxfaXRlbXMoUk9PVCkKICAgICNBbGw9W18gZm9yIF8gaW4gc29ydGVkKG9zLmxpc3RkaXIoUk9PVCkpIGlmIG5vdCBfLnN0YXJ0c3dpdGgoJy4nKSBdCiAgICAKICAgIGZvciBmbGFnIGluIFsic3RhcnRlZCIsInN0b3BwZWQiLCJlbmFibGVkIiwiZGlzYWJsZWQiXToKICAgICAgICBpZiBmbGFnIGluIGZsYWdzOgogICAgICAgICAgICBuYW1lcys9W18gZm9yIF8gaW4gQWxsIGlmIGZsYWcudGl0bGUoKSBpbiBDTEFTUyhfKS5TdGF0dXMoKSBdCiAgICAgICAgICAgIGRlbCBmbGFnc1tmbGFnXQoKICAgIGlmICJhbGwiIGluIGZsYWdzOgogICAgICAgIG5hbWVzKz1BbGwKICAgICAgICBkZWwgZmxhZ3NbImFsbCJdCiAgICBpZiBuYW1lcz09W106CiAgICAgICAgcHJpbnQoZiJObyB7Q0xBU1MuX19uYW1lX18ubG93ZXIoKX1zIHNwZWNpZmllZCEiKQogICAgICAgIGV4aXQoKQogICAgcmV0dXJuIG5hbWVzCgpkZWYgZmxhdHRlbl9saXN0KGl0ZW1zKToKICAgICIiIllpZWxkIGl0ZW1zIGZyb20gYW55IG5lc3RlZCBpdGVyYWJsZS4iIiIKICAgIGZvciB4IGluIGl0ZW1zOgogICAgICAgIGlmIGlzaW5zdGFuY2UoeCwgdHlwaW5nLkl0ZXJhYmxlKSBhbmQgbm90IGlzaW5zdGFuY2UoeCwgKHN0ciwgYnl0ZXMpKToKICAgICAgICAgICAgZm9yIHN1Yl94IGluIGZsYXR0ZW5fbGlzdCh4KToKICAgICAgICAgICAgICAgIHlpZWxkIHN1Yl94CiAgICAgICAgZWxzZToKICAgICAgICAgICAgeWllbGQgeAoKZGVmIHByaW50X2xpc3QobCk6CiAgICBmb3IgZWxlbWVudCBpbiBsOgogICAgICAgIGlmIGVsZW1lbnQgaXMgTm9uZToKICAgICAgICAgICAgcHJpbnQoZW5kPScnKQogICAgICAgIGVsc2U6CiAgICAgICAgICAgIHByaW50KGVsZW1lbnQpCgpkZWYgc3BsaXRfc3RyaW5nX2J5X2NoYXIoc3RyaW5nLGNoYXI9JzonKToKICAgIFBBVFRFUk4gPSByZS5jb21waWxlKHJmJycnKCg/OlteXHtjaGFyfSInXXwiW14iXSoifCdbXiddKicpKyknJycpCiAgICByZXR1cm4gW18gZm9yIF8gaW4gbGlzdChQQVRURVJOLnNwbGl0KHN0cmluZykpIGlmIF8gbm90IGluIFsnJywgY2hhcl1dCgoKZGVmIHNoZWxsX2NvbW1hbmQoY29tbWFuZCxzdGRvdXQ9c3VicHJvY2Vzcy5QSVBFLHN0ZGVycj1zdWJwcm9jZXNzLlNURE9VVCxhcmJpdHJhcnk9RmFsc2UsYmxvY2s9VHJ1ZSxlbnY9Tm9uZSk6CiAgICBwcm9jZXNzID0gc3VicHJvY2Vzcy5Qb3Blbihjb21tYW5kLCBzdGRvdXQ9c3Rkb3V0LCBzdGRlcnI9c3RkZXJyLHVuaXZlcnNhbF9uZXdsaW5lcz1UcnVlLHNoZWxsPWFyYml0cmFyeSxlbnY9ZW52KQogICAgaWYgYmxvY2s6CiAgICAgICAgcmV0dXJuIHByb2Nlc3MuY29tbXVuaWNhdGUoKVswXQoKZGVmIHdhaXRfdW50aWxfcGlkX2V4aXRzKHBpZCk6CiAgICAKICAgIGRlZiBwaWRfZXhpc3RzKHBpZCk6ICAgCiAgICAgICAgIiIiIENoZWNrIEZvciB0aGUgZXhpc3RlbmNlIG9mIGEgdW5peCBwaWQuICIiIgogICAgICAgIGlmIHNoZWxsX2NvbW1hbmQoWyJwcyIsICItb3N0YXQ9IixzdHIocGlkKV0pPT0iWlxuIjogI1pvbWJpZQogICAgICAgIAogICAgICAgICAgICByZXR1cm4gRmFsc2UgCiAgICAgICAgdHJ5OgogICAgICAgICAgICBvcy5raWxsKHBpZCwgMCkKICAgICAgICBleGNlcHQgT1NFcnJvcjoKICAgICAgICAgICAgcmV0dXJuIEZhbHNlCiAgICAgICAgZWxzZToKICAgICAgICAgICAgcmV0dXJuIFRydWUKICAgICAgICAgICAgCiAgICB3aGlsZSBwaWRfZXhpc3RzKHBpZCk6CiAgICAgICAgdGltZS5zbGVlcCgwLjI1KQogICAgICAgIApkZWYga2lsbF9wcm9jZXNzX2dyYWNlZnVsbHkocGlkKToKICAgIHByaW50KHBpZCkKICAgIHRyeToKICAgICAgICBvcy5raWxsKHBpZCxzaWduYWwuU0lHVEVSTSkKICAgICAgICB0cnk6CiAgICAgICAgICAgIG9zLndhaXRwaWQocGlkLDApCiAgICAgICAgZXhjZXB0IENoaWxkUHJvY2Vzc0Vycm9yOiAjTm90IGEgY2hpbGQgcHJvY2VzcyBzbyBtb3ZlIG9uCiAgICAgICAgICAgIHBhc3MKICAgICAgICB3YWl0X3VudGlsX3BpZF9leGl0cyhwaWQpCiAgICBleGNlcHQgUHJvY2Vzc0xvb2t1cEVycm9yOgogICAgICAgIHBhc3MKICAgIApkZWYgZXh0cmFjdF9hcmd1bWVudHMoKToKICAgIGFyZ3VtZW50cz1zeXMuYXJndlsxOl0KICAgIHRyeToKICAgICAgICBGVU5DVElPTj1hcmd1bWVudHNbMF0KICAgIGV4Y2VwdCBJbmRleEVycm9yOgogICAgICAgIHByaW50KCJObyBmdW5jdGlvbiBzcGVjaWZpZWQhIikKICAgICAgICBleGl0KCkKICAgIGFyZ3VtZW50cz1hcmd1bWVudHNbMTpdCiAgICAKICAgIE5BTUVTPVtdCiAgICBGTEFHUz1hcmd1bWVudHMKICAgIGZvciBpIGluIHJhbmdlKGxlbihhcmd1bWVudHMpKToKICAgICAgICBpZiBub3QgYXJndW1lbnRzW2ldLnN0YXJ0c3dpdGgoIi0tIik6CiAgICAgICAgICAgIEZMQUdTPWFyZ3VtZW50c1s6aV0KICAgICAgICAgICAgTkFNRVM9YXJndW1lbnRzW2k6XQogICAgICAgICAgICBicmVhawogICAgICAgICAgICAKICAgIGZsYWdzX3RlbXA9e30KICAgIGZvciBmbGFnIGluIEZMQUdTOgogICAgICAgIGZsYWc9ZmxhZy5zcGxpdCgnPScsMSkgI1NwbGl0IGV2ZXJ5IGZsYWcgaW4gRkxBR1MgYnkgJz0nCiAgICAgICAgaWYgbGVuKGZsYWcpPT0xOgogICAgICAgICAgICBmbGFnLmFwcGVuZCgnJykgI1BhZCBvdXQgdGhlIGZsYWcgYXJyYXkKICAgICAgICBmbGFnWzBdPWZsYWdbMF1bMjpdICNSZW1vdmUgdGhlICctLScKICAgICAgICBmbGFnc190ZW1wW2ZsYWdbMF1dPWZsYWdbMV0KICAgICAgICAKICAgIEZMQUdTPWZsYWdzX3RlbXAKICAgIHJldHVybiAoTkFNRVMsRkxBR1MsRlVOQ1RJT04pCgpkZWYgYWRkX2Vudmlyb25tZW50X3ZhcmlhYmxlX3RvX3N0cmluZyhzdHJpbmcsZW52X3Zhcik6CiAgICByZXR1cm4gc3RyaW5nK2YiOyBleHBvcnQge2Vudl92YXJ9IgoKZGVmIHdhaXQoZGVsYXk9Tm9uZSk6CiAgICB0aHJlYWRpbmcuRXZlbnQoKS53YWl0KHRpbWVvdXQ9ZGVsYXkpCgpkZWYgZXhlY3V0ZV9jbGFzc19tZXRob2QoY2xhc3NfaW5zdGFuY2UsZnVuY3Rpb24pOgogICAgaWYgbm90IGNhbGxhYmxlKGdldGF0dHIoY2xhc3NfaW5zdGFuY2UsIGZ1bmN0aW9uLnRpdGxlKCksTm9uZSkpOgogICAgICAgICAgICBwcmludChmIkNvbW1hbmQge2Z1bmN0aW9ufSBkb2Vzbid0IGV4aXN0ISIpCiAgICAgICAgICAgIGV4aXQoKQogICAgZWxzZToKICAgICAgICByZXR1cm4gbGlzdChmbGF0dGVuX2xpc3QoW2dldGF0dHIoY2xhc3NfaW5zdGFuY2UsZnVuY3Rpb24udGl0bGUoKSkoKV0pKQoKZGVmIGNoZWNrX2lmX2VsZW1lbnRfYW55X2lzX2luX2xpc3QoZWxlbWVudHMsX2xpc3QpOgogICAgcmV0dXJuIGFueShfIGluIF9saXN0IGZvciBfIGluIGVsZW1lbnRzKQogICAgCmRlZiBleHBvcnRfbWV0aG9kc19mcm9tX3NlbGYoc2VsZik6CiAgICBtZXRob2RzPXt9CiAgICBmb3IgZnVuYyBpbiBbZnVuYyBmb3IgZnVuYyBpbiBkaXIoc2VsZikgaWYgY2FsbGFibGUoZ2V0YXR0cihzZWxmLCBmdW5jKSkgYW5kIG5vdCBmdW5jLnN0YXJ0c3dpdGgoJ19fJyldOgogICAgICAgIGlmIG5vdCBmdW5jLnN0YXJ0c3dpdGgoJ18nKToKICAgICAgICAgICAgbWV0aG9kc1tmdW5jXT1nZXRhdHRyKHNlbGYsZnVuYykKICAgIAogICAgcmV0dXJuIG1ldGhvZHMKCmRlZiBleGVjdXRlKHNlbGYsZmlsZSk6CiAgICB0cnk6CiAgICAgICAgaWYgbm90IGlzaW5zdGFuY2UoZmlsZSxzdHIpOiAjQXNzdW1lIGZpbGUgaXMgZmlsZSBvYmplY3QKICAgICAgICAgICAgY29kZT1maWxlLnJlYWQoKQogICAgICAgICAgICBmaWxlLmNsb3NlKCkKICAgICAgICBlbHNlOgogICAgICAgICAgICBjb2RlPWZpbGUKICAgICAgICByZXR1cm4gZXhlYyhjb2RlLHNlbGYuZ2xvYmFscyxsb2NhbHMoKSkKICAgIGV4Y2VwdDoKICAgICAgICB0cmFjZWJhY2sucHJpbnRfZXhjKCkKICAgICAgICBzZWxmLlN0b3AoKQogICAgICAgICAgICAKZGVmIHdyYXBfYWxsX21ldGhvZHNfaW5fY2xhc3Nfd2l0aF9jaGRpcl9jb250ZXh0bWFuYWdlcihzZWxmLHBhdGgpOgogICAgQGNvbnRleHRsaWIuY29udGV4dG1hbmFnZXIKICAgIGRlZiBzZXRfZGlyZWN0b3J5KHBhdGgpOgogICAgICAgICIiIlNldHMgdGhlIGN3ZCB3aXRoaW4gdGhlIGNvbnRleHQKICAgIAogICAgICAgIEFyZ3M6CiAgICAgICAgICAgIHBhdGggKFBhdGgpOiBUaGUgcGF0aCB0byB0aGUgY3dkCiAgICAKICAgICAgICBZaWVsZHM6CiAgICAgICAgICAgIE5vbmUKICAgICAgICAiIiIKICAgIAogICAgICAgIG9yaWdpbiA9IG9zLnBhdGguYWJzcGF0aChvcy5nZXRjd2QoKSkKICAgICAgICB0cnk6CiAgICAgICAgICAgIGlmIG9zLnBhdGguaXNkaXIocGF0aCk6CiAgICAgICAgICAgICAgICBvcy5jaGRpcihwYXRoKQogICAgICAgICAgICB5aWVsZAogICAgICAgIGZpbmFsbHk6CiAgICAgICAgICAgICAgICBvcy5jaGRpcihvcmlnaW4pCiAgICAKICAgIGRlZiB3cmFwcGVyKGZ1bmMpOgogICAgICAgIGRlZiBuZXdfZnVuYygqYXJncywgKiprd2FyZ3MpOgogICAgICAgICAgICB3aXRoIHNldF9kaXJlY3RvcnkocGF0aCk6CiAgICAgICAgICAgICAgICByZXR1cm4gZnVuYygqYXJncywgKiprd2FyZ3MpCiAgICAgICAgcmV0dXJuIG5ld19mdW5jCiAgICAgICAgICAgIAogICAgZm9yIGZ1bmMgaW4gW2Z1bmMgZm9yIGZ1bmMgaW4gZGlyKHNlbGYpIGlmIGNhbGxhYmxlKGdldGF0dHIoc2VsZiwgZnVuYykpIGFuZCBub3QgZnVuYy5zdGFydHN3aXRoKCdfXycpXToKICAgICAgICBzZXRhdHRyKHNlbGYsZnVuYyx3cmFwcGVyKGdldGF0dHIoc2VsZixmdW5jKSkpCmNsYXNzIENsYXNzOgogICAgZGVmIF9faW5pdF9fKHNlbGYsY2xhc3Nfc2VsZixfbmFtZSxfZmxhZ3MsX3dvcmtkaXIpOgogICAgICAgIHNlbGYuc2VsZj1jbGFzc19zZWxmCiAgICAgICAgc2VsZi5uYW1lPUNMQVNTLl9fbmFtZV9fCiAgICAgICAgCiAgICAgICAgc2VsZi5zZWxmLm5hbWU9X25hbWUKICAgICAgICAKICAgICAgICBzZWxmLnNlbGYuZmxhZ3M9Z2V0X3ZhbHVlKF9mbGFncyx7fSkKICAgICAgICAKIyAgICAgICAgaWYgbm90IG9zLnBhdGguaXNkaXIoZiJ7Uk9PVH0ve3NlbGYuc2VsZi5uYW1lfSIpOgojICAgICAgICAgICAgIHJhaXNlIERvZXNOb3RFeGlzdCgpCiMgICAgICAgICAgICAgcmV0dXJuCiAgICAgICAgICAgICAKICAgICAgICBzZWxmLnNlbGYudGVtcD1vcy5wYXRoLmpvaW4oZ2V0X3RlbXBkaXIoKSxzZWxmLm5hbWUudGl0bGUoKSsicyIsc2VsZi5zZWxmLm5hbWUpCiAgICAgICAgc2VsZi5zZWxmLmxvZz1vcy5wYXRoLmpvaW4oc2VsZi5zZWxmLnRlbXAsImxvZyIpCiAgICAgICAgc2VsZi5zZWxmLmxvY2s9b3MucGF0aC5qb2luKHNlbGYuc2VsZi50ZW1wLCJsb2NrIikKICAgICAgICAKICAgICAgICBvcy5tYWtlZGlycyhzZWxmLnNlbGYudGVtcCxleGlzdF9vaz1UcnVlKQogICAgICAgIAogICAgICAgIHdyYXBfYWxsX21ldGhvZHNfaW5fY2xhc3Nfd2l0aF9jaGRpcl9jb250ZXh0bWFuYWdlcihzZWxmLnNlbGYsZiJ7Uk9PVH0ve3NlbGYuc2VsZi5uYW1lfSIpCiAgICAgICAgc2VsZi5zZWxmLndvcmtkaXI9X3dvcmtkaXIKICAgICAgICAKICAgICAgICBzZWxmLnNlbGYuZ2xvYmFscz1HTE9CQUxTLmNvcHkoKQogICAgICAgIHNlbGYuc2VsZi5nbG9iYWxzLnVwZGF0ZShleHBvcnRfbWV0aG9kc19mcm9tX3NlbGYoc2VsZi5zZWxmKSkKICAgICAgICAKICAgICAgICAKICAgIGRlZiBzdG9wKHNlbGYpOgogICAgICAgIGlmICJTdG9wcGVkIiBpbiBzZWxmLnNlbGYuU3RhdHVzKCk6CiAgICAgICAgICAgIHJldHVybiBmIntzZWxmLm5hbWV9IHtzZWxmLnNlbGYubmFtZX0gaXMgYWxyZWFkeSBzdG9wcGVkIgogICAgICAgIAogICAgICAgIGZvciBwaWQgaW4gc2VsZi5zZWxmLlBzKCJtYWluIik6CiAgICAgICAgICAgIGtpbGxfcHJvY2Vzc19ncmFjZWZ1bGx5KHBpZCkKICAgICAgICAKICAgICAgICBmb3IgZmlsZSBpbiBbImxvZyIsImxvY2siXToKICAgICAgICAgICAgdHJ5OgogICAgICAgICAgICAgICBvcy5yZW1vdmUoZ2V0YXR0cihzZWxmLnNlbGYsZmlsZSkpCiAgICAgICAgICAgIGV4Y2VwdCBGaWxlTm90Rm91bmRFcnJvcjoKICAgICAgICAgICAgICAgIHBhc3MKCiAgICBkZWYgcmVzdGFydChzZWxmKToKICAgICAgICByZXR1cm4gW3NlbGYuc2VsZi5TdG9wKCksc2VsZi5zZWxmLlN0YXJ0KCldCiAgICAKICAgIGRlZiBnZXRfbWFpbl9wcm9jZXNzKHNlbGYpOgogICAgICAgIGlmIG5vdCBvcy5wYXRoLmlzZmlsZShzZWxmLnNlbGYubG9jayk6CiAgICAgICAgICAgICAgICByZXR1cm4gW10KICAgICAgICBlbHNlOgogICAgICAgICAgICByZXR1cm4gbGlzdChtYXAoaW50LFtfIGZvciBfIGluIHNoZWxsX2NvbW1hbmQoWyJsc29mIiwiLXQiLCItdyIsc2VsZi5zZWxmLmxvY2tdKS5zcGxpdGxpbmVzKCldKSkKICAgIAogICAgZGVmIGxpc3Qoc2VsZik6CiAgICAgICAgcmV0dXJuIHNlbGYuc2VsZi5uYW1lCiAgICAKICAgICAgICAKICAgIGRlZiB3b3JrZGlyKHNlbGYsd29ya19kaXIpOgogICAgICAgIHNlbGYuc2VsZi53b3JrZGlyPW9zLnBhdGguam9pbihzZWxmLnNlbGYud29ya2Rpcix3b3JrX2RpcikKICAgICAgICAjUmVtb3ZlIHRyYWlsaW5nIHNsYXNoZXMsIGJ1dCBvbmx5IGZvciBzdHJpbmdzIHRoYXQgYXJlIG5vdCAvCiAgICAgICAgI2lmIHdvcmtfZGlyLmVuZHN3aXRoKCcvJykgYW5kIGxlbih3b3JrX2Rpcik+MToKICAgICAgICAgICAgI3dvcmtfZGlyPXdvcmtfZGlyWzotMV0KICAgICAgICAgICAgIwogICAgICAgICNpZiB3b3JrX2Rpci5zdGFydHN3aXRoKCIvIik6CiAgICAgICAgICAgICNzZWxmLnNlbGYud29ya2Rpcj13b3JrX2RpcgogICAgICAgICNlbHNlOiAgICAKICAgICAgICAgICAgI3NlbGYuc2VsZi53b3JrZGlyKz0nLycrd29ya19kaXIKICAgICAgICAKICAgICAgICAjUmVtb3ZlIHJlcGVhdGVkIC8gaW4gd29ya2RpcgogICAgICAgICNzZWxmLnNlbGYud29ya2Rpcj1yZS5zdWIocicoLylcMSsnLCByJ1wxJyxzZWxmLnNlbGYud29ya2RpcikKCiAgICBkZWYgc3RhdHVzKHNlbGYpOgogICAgICAgIGlmIG9zLnBhdGguaXNmaWxlKHNlbGYuc2VsZi5sb2cpOgogICAgICAgICAgICByZXR1cm4gWyJTdGFydGVkIl0KICAgICAgICBlbHNlOgogICAgICAgICAgICByZXR1cm4gWyJTdG9wcGVkIl0KCiAgICBkZWYgbG9vcChzZWxmLGNvbW1hbmQsZGVsYXk9NjApOgogICAgICAgIGlmIGlzaW5zdGFuY2UoY29tbWFuZCxzdHIpOgogICAgICAgICAgICBkZWYgZnVuYygpOgogICAgICAgICAgICAgICAgd2hpbGUgVHJ1ZToKICAgICAgICAgICAgICAgICAgICBzZWxmLnNlbGYuUnVuKGNvbW1hbmQpCiAgICAgICAgICAgICAgICAgICAgc2VsZi5zZWxmLldhaXQoZGVsYXkpCiAgICAgICAgZWxzZToKICAgICAgICAgICAgZGVmIGZ1bmMoKToKICAgICAgICAgICAgICAgIHdoaWxlIFRydWU6ICAKICAgICAgICAgICAgICAgICAgICBjb21tYW5kKCkKICAgICAgICAgICAgICAgICAgICBzZWxmLnNlbGYuV2FpdChkZWxheSkKICAgICAgICBzZWxmLnNlbGYuUnVuKCIiKSAjTmVlZGVkIHRvIGF2b2lkIHJhY2UgY29uZGl0aW9ucyB3aXRoIGEgcmFjZSB0aGF0J3MgcmlnaHQgYWZ0ZXIgLS0tIGp1c3QgcnVuIHNlbGYuc2VsZi5SdW4gb25jZQogICAgICAgIHRocmVhZGluZy5UaHJlYWQodGFyZ2V0PWZ1bmMsZGFlbW9uPVRydWUpLnN0YXJ0KCkKICAgICAgIAogICAgZGVmIGtpbGxfYXV4aWxpYXJ5X3Byb2Nlc3NlcyhzZWxmKToKICAgICAgICB3aGlsZSBzZWxmLnNlbGYuUHMoImF1eGlsaWFyeSIpIT1bXTogI0lmIG5ldyBwcm9jZXNzZXMgd2VyZSBzdGFydGVkIGR1cmluZyBhbiBpdGVyYXRpb24sIGdvIG92ZXIgaXQgYWdhaW4sIHVudGlsIHlvdSBraWxsZWQgdGhlbSBhbGwKICAgICAgICAgICAgZm9yIHBpZCBpbiBzZWxmLnNlbGYuUHMoImF1eGlsaWFyeSIpOgogICAgICAgICAgICAgICAga2lsbF9wcm9jZXNzX2dyYWNlZnVsbHkocGlkKQogICAgICAgICAgICAgICAgCiAgICBkZWYgbG9nKHNlbGYpOgogICAgICAgIHNoZWxsX2NvbW1hbmQoWyJsZXNzIiwiK0ciLCItZiIsIi1yIixzZWxmLnNlbGYubG9nXSxzdGRvdXQ9Tm9uZSkKICAgIAogICAgZGVmIGRlbGV0ZShzZWxmKToKICAgICAgICBzZWxmLnNlbGYuU3RvcCgpCiAgICAgICAgc2h1dGlsLnJtdHJlZShmIntST09UfS97c2VsZi5zZWxmLm5hbWV9IikKICAgIAogICAgZGVmIHdhdGNoKHNlbGYpOgogICAgICAgIHRyeToKICAgICAgICAgICAgc2hlbGxfY29tbWFuZChbInRhaWwiLCItZiIsIi0tZm9sbG93PW5hbWUiLHNlbGYuc2VsZi5sb2ddLHN0ZG91dD1Ob25lKQogICAgICAgIGV4Y2VwdCBLZXlib2FyZEludGVycnVwdDoKICAgICAgICAgICAgcGFzcwogICAgCgo=').decode("utf-8"),utils_module.__dict__)
sys.modules["utils"]=utils_module
import subprocess
import os
import signal

import utils

import importlib.machinery, shutil

utils.GLOBALS=globals()


def flatten(*args, **kwargs):
    return utils.flatten_list(*args, **kwargs)

def print_result(*args, **kwargs):
    return utils.print_list(*args, **kwargs)

def split_by_char(*args, **kwargs):
    return utils.split_by_char(*args, **kwargs)
    
class Service:
    def __init__(self,_name,_flags=None,_env=None,_workdir='.'):
        self.Class = utils.Class(self,_name,_flags,_workdir)
        
        self.env=utils.get_value(_env,f"export SERVICE_NAME={self.name}")
        
        self.temp_services=[]
        
        self.exit_cmds=[]

    #Functions to be used in *service.py
    def Run(self,command="",pipe=False,track=True):
        with open(self.log,"a+") as log_file:
            if track:
                log_file.write(f"Command: {command}\n")
                log_file.flush()

            #Pipe output to variable
            if pipe:
                stdout=subprocess.PIPE
                stderr=subprocess.DEVNULL
            #Print output to file
            else:
                stdout=log_file
                stderr=subprocess.STDOUT
            return utils.shell_command(f"{self.env if track else 'true'}; cd {self.workdir}; {command}",stdout=stdout,stderr=stderr,arbitrary=True)
    
    def Ps(self,process=None):
        
        #Find main process
        if process=="main" or ("main" in self.flags):
            return self.Class.get_main_process()
            
        #Find processes running under main Start script
        elif process=="auxiliary" or ("auxiliary" in self.flags):
            processes=utils.shell_command(["ps","auxwwe"]).splitlines()
            processes=[_.split()[1] for _ in processes if f"SERVICE_NAME={self.name}" in _]
            return list(map(int,processes))

    
    def Env(self,*args, **kwargs):
        self.env=utils.add_environment_variable_to_string(self.env,*args, **kwargs)
    
    def Container(self,_container=None):
        #Convinence --- if conainer name is not specified, it will assume that the container is the same name as the service
        container = importlib.machinery.SourceFileLoader("gfg",shutil.which("container")).load_module()
        if not _container:
            _container=self.name
        
        _container=container.Container(_container)
        self.Down(lambda : _container.Stop())
        #self.Down(f"container stop {_container}")
        
        _container.Start()
        #self.Run(f"container start {_container}",track=False)
        
        self.Run(f"echo Started container {_container.name}",track=False)
        
        with open(self.log,"a+") as f:
            utils.shell_command(["tail","-f","-n","+1",_container.log],stdout=f,block=False,env=os.environ.copy() | {"SERVICE_NAME":self.name})
        
        container_main_pid=_container.Ps("main")[0]
        #container_main_pid=utils.shell_command(["container","ps","--main",_container],stdout=subprocess.PIPE)
        
        #Wait until container ends
        try:
            container_main_pid=int(container_main_pid)
            utils.wait_until_pid_exits(container_main_pid)
        except ValueError:
            pass
    
    def Down(self,func):
        if isinstance(func,str):
            #So func won't be overwritten
            func_str=func
            def func():
                self.Run(func_str)
        self.exit_cmds.append(func)
        
    def Loop(self,*args, **kwargs):
        self.Class.loop(*args, **kwargs)
        #Run(f'(while true; do "{command}"; sleep {delay}; done)')

    def Wait(self,*args, **kwargs):
        utils.wait(*args, **kwargs)
    
    def Exit(self,signum,frame):
        for cmd in self.exit_cmds:
            cmd()
            
        self.Class.kill_auxiliary_processes()
        
        exit()
    
    def Dependency(self,service):
        if "Stopped" in self.__class__(service).Status():
            #self.temp_services.append(service)
            #Kill service when stopping
            self.Down(self.__class__(service).Stop)
            #utils.shell_command(["service","start",service],stdout=subprocess.DEVNULL)
            self.__class__(service).Start()
    #Commands      
    def Start(self):
        
        if "Started" in self.Status():
            return f"Service {self.name} is already started"
        
        #If child, run code, then exit 
        if os.fork()==0:
            signal.signal(signal.SIGTERM,self.Exit)
            
            if os.path.exists("data"):
                self.Workdir("data")
            
            if "Enabled" in self.Status():
                service_file="service.py"
            else:
                service_file=".service.py"
                
            #Open a lock file so I can find it with lsof later
            lock_file=open(self.lock,"w+")
            
            #Run *service.py
            utils.execute(self,open(f"{ROOT}/{self.name}/{service_file}"))
            
            #Don't exit script yet.
            self.Wait()
            exit()
       
    def Stop(self):
        return [self.Class.stop()]
        
    def Restart(self):
        return self.Class.restart()
    
    
    def List(self):
        return self.Class.list()
    
    def Workdir(self,work_dir):
        self.Class.workdir(work_dir)

    def Init(self):
        os.makedirs(f"{ROOT}/{self.name}",exist_ok=True)
        os.chdir(f"{ROOT}/{self.name}")
        os.makedirs("data",exist_ok=True)
        with open(f".service.py",'a'):
            pass
        
        if 'no-edit' not in self.flags:
            self.Edit()

    def Edit(self):
        if "Enabled" in self.Status():
            utils.shell_command([os.getenv("EDITOR","vi"),f"{ROOT}/{self.name}/service.py"],stdout=None)
        else:
            utils.shell_command([os.getenv("EDITOR","vi"),f"{ROOT}/{self.name}/.service.py"],stdout=None)
            
    def Status(self):
        return self.Class.status() + ["Enabled" if os.path.exists(f"{ROOT}/{self.name}/service.py") else "Disabled"]
    
    def Enable(self):
        if "Enabled" in self.Status():
            return [f"Service {self.name} is already enabled"]
        else:
            os.rename(f"{ROOT}/{self.name}/.service.py",f"{ROOT}/{self.name}/service.py")
        
        if 'now' in self.flags:
            return [self.Start()]

            
    def Disable(self):
        if "Disabled" in self.Status():
            return [f"Service {self.name} is already disabled"]
        else:
            os.rename(f"{ROOT}/{self.name}/service.py",f"{ROOT}/{self.name}/.service.py")
        
        if 'now' in self.flags:
            return [self.Stop()]

    def Log(self):
        self.Class.log()
    
    def Delete(self):
        self.Class.delete()
    
    def Watch(self):
        self.Class.watch()
utils.CLASS=Service
utils.ROOT=ROOT=utils.get_root_directory()
if __name__ == "__main__":
    
    NAMES,FLAGS,FUNCTION=utils.extract_arguments()
    
    for name in utils.list_items_in_root(NAMES, FLAGS): 
        item=utils.CLASS(name,FLAGS)
        result=utils.execute_class_method(item,FUNCTION)
        print_result(result)
        

    
