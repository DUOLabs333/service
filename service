#!/usr/bin/env python


import types
import sys
import base64
utils_module=types.ModuleType("utils")
#setattr(utils_module,"__file__",__file__)
exec(base64.b64decode(b'aW1wb3J0IHN1YnByb2Nlc3MKaW1wb3J0IHJlCmltcG9ydCB0ZW1wZmlsZQppbXBvcnQgb3MKaW1wb3J0IHBhdGhsaWIKaW1wb3J0IHNpZ25hbCAKaW1wb3J0IHRpbWUKaW1wb3J0IHN5cwppbXBvcnQgdHlwaW5nCmltcG9ydCBzaHV0aWwKaW1wb3J0IHRocmVhZGluZwppbXBvcnQgY29udGV4dGxpYgppbXBvcnQgd2FybmluZ3MKCmZvciB2YXIgaW4gWyJST09UIiwiR0xPQkFMUyIsIkNMQVNTIiwiZ2V0X2FsbF9pdGVtcyJdOgogICAgZ2xvYmFscygpW3Zhcl09Tm9uZQogICAgCmRlZiBnZXRfdGVtcGRpcigpOgogICAgaWYgb3MudW5hbWUoKS5zeXNuYW1lPT0iRGFyd2luIjoKICAgICAgICByZXR1cm4gIi90bXAiCiAgICBlbHNlOgogICAgICAgIHJldHVybiB0ZW1wZmlsZS5nZXR0ZW1wZGlyKCkKICAgIApjbGFzcyBEb2VzTm90RXhpc3QoRXhjZXB0aW9uKToKICAgIHBhc3MKCmRlZiBnZXRfdmFsdWUodmFyaWFibGUsZGVmYXVsdCk6CglpZiBub3QgdmFyaWFibGU6CgkJcmV0dXJuIGRlZmF1bHQKCWVsc2U6CgkJcmV0dXJuIHZhcmlhYmxlCgpkZWYgZ2V0X3Jvb3RfZGlyZWN0b3J5KHJvb3RfdmFyaWFibGU9Tm9uZSxkZWZhdWx0X3ZhbHVlPU5vbmUpOgogICAgcm9vdF92YXJpYWJsZT1nZXRfdmFsdWUocm9vdF92YXJpYWJsZSxmIntDTEFTUy5fX25hbWVfXy51cHBlcigpfV9ST09UIikKICAgIGRlZmF1bHRfdmFsdWU9Z2V0X3ZhbHVlKGRlZmF1bHRfdmFsdWUsZiJ7b3MuZW52aXJvblsnSE9NRSddfS97Q0xBU1MuX19uYW1lX18udGl0bGUoKX1zIikKICAgIHJldHVybiBvcy5wYXRoLmV4cGFuZHVzZXIob3MuZ2V0ZW52KHJvb3RfdmFyaWFibGUsZGVmYXVsdF92YWx1ZSkpCgoKZGVmIGxpc3RfaXRlbXNfaW5fcm9vdChuYW1lcyxmbGFncyk6CiAgICBnbG9iYWwgZ2V0X2FsbF9pdGVtcwogICAgaWYgbm90IGdldF9hbGxfaXRlbXM6CiAgICAgICAgZ2V0X2FsbF9pdGVtcyA9IGxhbWJkYSByb290OiBbXyBmb3IgXyBpbiBzb3J0ZWQob3MubGlzdGRpcihyb290ICkpIGlmIG5vdCBfLnN0YXJ0c3dpdGgoJy4nKSBdICNGYWxsIGJhY2sgdG8gZGVmYXVsdCBpZiBubyBzcGVjaWFsIGZ1bmN0aW9uIGlzIGRlZmluZWQKICAgICAgICAKICAgIEFsbD1nZXRfYWxsX2l0ZW1zKFJPT1QpCiAgICAjQWxsPVtfIGZvciBfIGluIHNvcnRlZChvcy5saXN0ZGlyKFJPT1QpKSBpZiBub3QgXy5zdGFydHN3aXRoKCcuJykgXQogICAgCiAgICBmb3IgZmxhZyBpbiBbInN0YXJ0ZWQiLCJzdG9wcGVkIiwiZW5hYmxlZCIsImRpc2FibGVkIl06CiAgICAgICAgaWYgZmxhZyBpbiBmbGFnczoKICAgICAgICAgICAgbmFtZXMrPVtfIGZvciBfIGluIEFsbCBpZiBmbGFnLnRpdGxlKCkgaW4gQ0xBU1MoXykuU3RhdHVzKCkgXQogICAgICAgICAgICBkZWwgZmxhZ3NbZmxhZ10KCiAgICBpZiAiYWxsIiBpbiBmbGFnczoKICAgICAgICBuYW1lcys9QWxsCiAgICAgICAgZGVsIGZsYWdzWyJhbGwiXQogICAgaWYgbmFtZXM9PVtdOgogICAgICAgIHByaW50KGYiTm8ge0NMQVNTLl9fbmFtZV9fLmxvd2VyKCl9cyBzcGVjaWZpZWQhIikKICAgICAgICBleGl0KCkKICAgIHJldHVybiBuYW1lcwoKZGVmIGZsYXR0ZW5fbGlzdChpdGVtcyk6CiAgICAiIiJZaWVsZCBpdGVtcyBmcm9tIGFueSBuZXN0ZWQgaXRlcmFibGUuIiIiCiAgICBmb3IgeCBpbiBpdGVtczoKICAgICAgICBpZiBpc2luc3RhbmNlKHgsIHR5cGluZy5JdGVyYWJsZSkgYW5kIG5vdCBpc2luc3RhbmNlKHgsIChzdHIsIGJ5dGVzKSk6CiAgICAgICAgICAgIGZvciBzdWJfeCBpbiBmbGF0dGVuX2xpc3QoeCk6CiAgICAgICAgICAgICAgICB5aWVsZCBzdWJfeAogICAgICAgIGVsc2U6CiAgICAgICAgICAgIHlpZWxkIHgKCmRlZiBwcmludF9saXN0KGwpOgogICAgZm9yIGVsZW1lbnQgaW4gbDoKICAgICAgICBpZiBlbGVtZW50IGlzIE5vbmU6CiAgICAgICAgICAgIHByaW50KGVuZD0nJykKICAgICAgICBlbHNlOgogICAgICAgICAgICBwcmludChlbGVtZW50KQoKZGVmIHNwbGl0X3N0cmluZ19ieV9jaGFyKHN0cmluZyxjaGFyPSc6Jyk6CiAgICBQQVRURVJOID0gcmUuY29tcGlsZShyZicnJygoPzpbXlx7Y2hhcn0iJ118IlteIl0qInwnW14nXSonKSspJycnKQogICAgcmV0dXJuIFtfIGZvciBfIGluIGxpc3QoUEFUVEVSTi5zcGxpdChzdHJpbmcpKSBpZiBfIG5vdCBpbiBbJycsIGNoYXJdXQoKCmRlZiBzaGVsbF9jb21tYW5kKGNvbW1hbmQsc3Rkb3V0PXN1YnByb2Nlc3MuUElQRSxzdGRlcnI9c3VicHJvY2Vzcy5TVERPVVQsYXJiaXRyYXJ5PUZhbHNlLGJsb2NrPVRydWUsZW52PU5vbmUpOgogICAgcHJvY2VzcyA9IHN1YnByb2Nlc3MuUG9wZW4oY29tbWFuZCwgc3Rkb3V0PXN0ZG91dCwgc3RkZXJyPXN0ZGVycix1bml2ZXJzYWxfbmV3bGluZXM9VHJ1ZSxzaGVsbD1hcmJpdHJhcnksZW52PWVudikKICAgIGlmIGJsb2NrOgogICAgICAgIHJldHVybiBwcm9jZXNzLmNvbW11bmljYXRlKClbMF0KCmRlZiB3YWl0X3VudGlsX3BpZF9leGl0cyhwaWQpOgogICAgCiAgICBkZWYgcGlkX2V4aXN0cyhwaWQpOiAgIAogICAgICAgICIiIiBDaGVjayBGb3IgdGhlIGV4aXN0ZW5jZSBvZiBhIHVuaXggcGlkLiAiIiIKICAgICAgICB0cnk6CiAgICAgICAgICAgIG9zLmtpbGwocGlkLCAwKQogICAgICAgIGV4Y2VwdCBPU0Vycm9yOgogICAgICAgICAgICByZXR1cm4gRmFsc2UKICAgICAgICBlbHNlOgogICAgICAgICAgICByZXR1cm4gVHJ1ZQogICAgICAgICAgICAKICAgIHdoaWxlIHBpZF9leGlzdHMocGlkKToKICAgICAgICB0aW1lLnNsZWVwKDAuMjUpCiAgICAgICAgCmRlZiBraWxsX3Byb2Nlc3NfZ3JhY2VmdWxseShwaWQpOgogICAgcHJpbnQocGlkKQogICAgdHJ5OgogICAgICAgIG9zLmtpbGwocGlkLHNpZ25hbC5TSUdURVJNKQogICAgICAgIHRyeToKICAgICAgICAgICAgb3Mud2FpdHBpZChwaWQsMCkKICAgICAgICBleGNlcHQgQ2hpbGRQcm9jZXNzRXJyb3I6ICNOb3QgYSBjaGlsZCBwcm9jZXNzIHNvIG1vdmUgb24KICAgICAgICAgICAgcGFzcwogICAgICAgIHdhaXRfdW50aWxfcGlkX2V4aXRzKHBpZCkKICAgIGV4Y2VwdCBQcm9jZXNzTG9va3VwRXJyb3I6CiAgICAgICAgcGFzcwogICAgCmRlZiBleHRyYWN0X2FyZ3VtZW50cygpOgogICAgYXJndW1lbnRzPXN5cy5hcmd2WzE6XQogICAgdHJ5OgogICAgICAgIEZVTkNUSU9OPWFyZ3VtZW50c1swXQogICAgZXhjZXB0IEluZGV4RXJyb3I6CiAgICAgICAgcHJpbnQoIk5vIGZ1bmN0aW9uIHNwZWNpZmllZCEiKQogICAgICAgIGV4aXQoKQogICAgYXJndW1lbnRzPWFyZ3VtZW50c1sxOl0KICAgIAogICAgTkFNRVM9W10KICAgIEZMQUdTPWFyZ3VtZW50cwogICAgZm9yIGkgaW4gcmFuZ2UobGVuKGFyZ3VtZW50cykpOgogICAgICAgIGlmIG5vdCBhcmd1bWVudHNbaV0uc3RhcnRzd2l0aCgiLS0iKToKICAgICAgICAgICAgRkxBR1M9YXJndW1lbnRzWzppXQogICAgICAgICAgICBOQU1FUz1hcmd1bWVudHNbaTpdCiAgICAgICAgICAgIGJyZWFrCiAgICAgICAgICAgIAogICAgZmxhZ3NfdGVtcD17fQogICAgZm9yIGZsYWcgaW4gRkxBR1M6CiAgICAgICAgZmxhZz1mbGFnLnNwbGl0KCc9JywxKSAjU3BsaXQgZXZlcnkgZmxhZyBpbiBGTEFHUyBieSAnPScKICAgICAgICBpZiBsZW4oZmxhZyk9PTE6CiAgICAgICAgICAgIGZsYWcuYXBwZW5kKCcnKSAjUGFkIG91dCB0aGUgZmxhZyBhcnJheQogICAgICAgIGZsYWdbMF09ZmxhZ1swXVsyOl0gI1JlbW92ZSB0aGUgJy0tJwogICAgICAgIGZsYWdzX3RlbXBbZmxhZ1swXV09ZmxhZ1sxXQogICAgICAgIAogICAgRkxBR1M9ZmxhZ3NfdGVtcAogICAgcmV0dXJuIChOQU1FUyxGTEFHUyxGVU5DVElPTikKCmRlZiBhZGRfZW52aXJvbm1lbnRfdmFyaWFibGVfdG9fc3RyaW5nKHN0cmluZyxlbnZfdmFyKToKICAgIHJldHVybiBzdHJpbmcrZiI7IGV4cG9ydCB7ZW52X3Zhcn0iCgpkZWYgd2FpdChkZWxheT1Ob25lKToKICAgIHRocmVhZGluZy5FdmVudCgpLndhaXQodGltZW91dD1kZWxheSkKCmRlZiBleGVjdXRlX2NsYXNzX21ldGhvZChjbGFzc19pbnN0YW5jZSxmdW5jdGlvbik6CiAgICBpZiBub3QgY2FsbGFibGUoZ2V0YXR0cihjbGFzc19pbnN0YW5jZSwgZnVuY3Rpb24udGl0bGUoKSxOb25lKSk6CiAgICAgICAgICAgIHByaW50KGYiQ29tbWFuZCB7ZnVuY3Rpb259IGRvZXNuJ3QgZXhpc3QhIikKICAgICAgICAgICAgZXhpdCgpCiAgICBlbHNlOgogICAgICAgIHJldHVybiBsaXN0KGZsYXR0ZW5fbGlzdChbZ2V0YXR0cihjbGFzc19pbnN0YW5jZSxmdW5jdGlvbi50aXRsZSgpKSgpXSkpCgpkZWYgY2hlY2tfaWZfZWxlbWVudF9hbnlfaXNfaW5fbGlzdChlbGVtZW50cyxfbGlzdCk6CiAgICByZXR1cm4gYW55KF8gaW4gX2xpc3QgZm9yIF8gaW4gZWxlbWVudHMpCiAgICAKZGVmIGV4cG9ydF9tZXRob2RzX2Zyb21fc2VsZihzZWxmKToKICAgIG1ldGhvZHM9e30KICAgIGZvciBmdW5jIGluIFtmdW5jIGZvciBmdW5jIGluIGRpcihzZWxmKSBpZiBjYWxsYWJsZShnZXRhdHRyKHNlbGYsIGZ1bmMpKSBhbmQgbm90IGZ1bmMuc3RhcnRzd2l0aCgnX18nKV06CiAgICAgICAgaWYgbm90IGZ1bmMuc3RhcnRzd2l0aCgnXycpOgogICAgICAgICAgICBtZXRob2RzW2Z1bmNdPWdldGF0dHIoc2VsZixmdW5jKQogICAgCiAgICByZXR1cm4gbWV0aG9kcwoKZGVmIGV4ZWN1dGUoc2VsZixmaWxlKToKICAgIGlmIG5vdCBpc2luc3RhbmNlKGZpbGUsc3RyKTogI0Fzc3VtZSBmaWxlIGlzIGZpbGUgb2JqZWN0CiAgICAgICAgY29kZT1maWxlLnJlYWQoKQogICAgICAgIGZpbGUuY2xvc2UoKQogICAgZWxzZToKICAgICAgICBjb2RlPWZpbGUKICAgIHJldHVybiBleGVjKGNvZGUsc2VsZi5nbG9iYWxzLGxvY2FscygpKQogICAgCmRlZiB3cmFwX2FsbF9tZXRob2RzX2luX2NsYXNzX3dpdGhfY2hkaXJfY29udGV4dG1hbmFnZXIoc2VsZixwYXRoKToKICAgIEBjb250ZXh0bGliLmNvbnRleHRtYW5hZ2VyCiAgICBkZWYgc2V0X2RpcmVjdG9yeShwYXRoKToKICAgICAgICAiIiJTZXRzIHRoZSBjd2Qgd2l0aGluIHRoZSBjb250ZXh0CiAgICAKICAgICAgICBBcmdzOgogICAgICAgICAgICBwYXRoIChQYXRoKTogVGhlIHBhdGggdG8gdGhlIGN3ZAogICAgCiAgICAgICAgWWllbGRzOgogICAgICAgICAgICBOb25lCiAgICAgICAgIiIiCiAgICAKICAgICAgICBvcmlnaW4gPSBvcy5wYXRoLmFic3BhdGgob3MuZ2V0Y3dkKCkpCiAgICAgICAgdHJ5OgogICAgICAgICAgICBpZiBvcy5wYXRoLmlzZGlyKHBhdGgpOgogICAgICAgICAgICAgICAgb3MuY2hkaXIocGF0aCkKICAgICAgICAgICAgeWllbGQKICAgICAgICBmaW5hbGx5OgogICAgICAgICAgICAgICAgb3MuY2hkaXIob3JpZ2luKQogICAgCiAgICBkZWYgd3JhcHBlcihmdW5jKToKICAgICAgICBkZWYgbmV3X2Z1bmMoKmFyZ3MsICoqa3dhcmdzKToKICAgICAgICAgICAgd2l0aCBzZXRfZGlyZWN0b3J5KHBhdGgpOgogICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmMoKmFyZ3MsICoqa3dhcmdzKQogICAgICAgIHJldHVybiBuZXdfZnVuYwogICAgICAgICAgICAKICAgIGZvciBmdW5jIGluIFtmdW5jIGZvciBmdW5jIGluIGRpcihzZWxmKSBpZiBjYWxsYWJsZShnZXRhdHRyKHNlbGYsIGZ1bmMpKSBhbmQgbm90IGZ1bmMuc3RhcnRzd2l0aCgnX18nKV06CiAgICAgICAgc2V0YXR0cihzZWxmLGZ1bmMsd3JhcHBlcihnZXRhdHRyKHNlbGYsZnVuYykpKQpjbGFzcyBDbGFzczoKICAgIGRlZiBfX2luaXRfXyhzZWxmLGNsYXNzX3NlbGYsX25hbWUsX2ZsYWdzLF93b3JrZGlyKToKICAgICAgICBzZWxmLnNlbGY9Y2xhc3Nfc2VsZgogICAgICAgIHNlbGYubmFtZT1DTEFTUy5fX25hbWVfXwogICAgICAgIAogICAgICAgIHNlbGYuc2VsZi5uYW1lPV9uYW1lCiAgICAgICAgCiAgICAgICAgc2VsZi5zZWxmLmZsYWdzPWdldF92YWx1ZShfZmxhZ3Mse30pCiAgICAgICAgCiMgICAgICAgIGlmIG5vdCBvcy5wYXRoLmlzZGlyKGYie1JPT1R9L3tzZWxmLnNlbGYubmFtZX0iKToKIyAgICAgICAgICAgICByYWlzZSBEb2VzTm90RXhpc3QoKQojICAgICAgICAgICAgIHJldHVybgogICAgICAgICAgICAgCiAgICAgICAgc2VsZi5zZWxmLnRlbXA9b3MucGF0aC5qb2luKGdldF90ZW1wZGlyKCksc2VsZi5uYW1lLnRpdGxlKCkrInMiLHNlbGYuc2VsZi5uYW1lKQogICAgICAgIHNlbGYuc2VsZi5sb2c9b3MucGF0aC5qb2luKHNlbGYuc2VsZi50ZW1wLCJsb2ciKQogICAgICAgIHNlbGYuc2VsZi5sb2NrPW9zLnBhdGguam9pbihzZWxmLnNlbGYudGVtcCwibG9jayIpCiAgICAgICAgCiAgICAgICAgb3MubWFrZWRpcnMoc2VsZi5zZWxmLnRlbXAsZXhpc3Rfb2s9VHJ1ZSkKICAgICAgICAKICAgICAgICB3cmFwX2FsbF9tZXRob2RzX2luX2NsYXNzX3dpdGhfY2hkaXJfY29udGV4dG1hbmFnZXIoc2VsZi5zZWxmLGYie1JPT1R9L3tzZWxmLnNlbGYubmFtZX0iKQogICAgICAgIHNlbGYuc2VsZi53b3JrZGlyPV93b3JrZGlyCiAgICAgICAgCiAgICAgICAgc2VsZi5zZWxmLmdsb2JhbHM9R0xPQkFMUy5jb3B5KCkKICAgICAgICBzZWxmLnNlbGYuZ2xvYmFscy51cGRhdGUoZXhwb3J0X21ldGhvZHNfZnJvbV9zZWxmKHNlbGYuc2VsZikpCiAgICAgICAgCiAgICAgICAgCiAgICBkZWYgc3RvcChzZWxmKToKICAgICAgICBpZiAiU3RvcHBlZCIgaW4gc2VsZi5zZWxmLlN0YXR1cygpOgogICAgICAgICAgICByZXR1cm4gZiJ7c2VsZi5uYW1lfSB7c2VsZi5zZWxmLm5hbWV9IGlzIGFscmVhZHkgc3RvcHBlZCIKICAgICAgICAKICAgICAgICBmb3IgcGlkIGluIHNlbGYuc2VsZi5QcygibWFpbiIpOgogICAgICAgICAgICBraWxsX3Byb2Nlc3NfZ3JhY2VmdWxseShwaWQpCiAgICAgICAgCiAgICAgICAgZm9yIGZpbGUgaW4gWyJsb2ciLCJsb2NrIl06CiAgICAgICAgICAgIHRyeToKICAgICAgICAgICAgICAgb3MucmVtb3ZlKGdldGF0dHIoc2VsZi5zZWxmLGZpbGUpKQogICAgICAgICAgICBleGNlcHQgRmlsZU5vdEZvdW5kRXJyb3I6CiAgICAgICAgICAgICAgICBwYXNzCgogICAgZGVmIHJlc3RhcnQoc2VsZik6CiAgICAgICAgcmV0dXJuIFtzZWxmLnNlbGYuU3RvcCgpLHNlbGYuc2VsZi5TdGFydCgpXQogICAgCiAgICBkZWYgZ2V0X21haW5fcHJvY2VzcyhzZWxmKToKICAgICAgICBpZiBub3Qgb3MucGF0aC5pc2ZpbGUoc2VsZi5zZWxmLmxvY2spOgogICAgICAgICAgICAgICAgcmV0dXJuIFtdCiAgICAgICAgZWxzZToKICAgICAgICAgICAgcmV0dXJuIGxpc3QobWFwKGludCxbXyBmb3IgXyBpbiBzaGVsbF9jb21tYW5kKFsibHNvZiIsIi10IiwiLXciLHNlbGYuc2VsZi5sb2NrXSkuc3BsaXRsaW5lcygpXSkpCiAgICAKICAgIGRlZiBsaXN0KHNlbGYpOgogICAgICAgIHJldHVybiBzZWxmLnNlbGYubmFtZQogICAgICAgIAogICAgZGVmIHdvcmtkaXIoc2VsZix3b3JrX2Rpcik6CiAgICAgICAgI1JlbW92ZSB0cmFpbGluZyBzbGFzaGVzLCBidXQgb25seSBmb3Igc3RyaW5ncyB0aGF0IGFyZSBub3QgLwogICAgICAgIGlmIHdvcmtfZGlyLmVuZHN3aXRoKCcvJykgYW5kIGxlbih3b3JrX2Rpcik+MToKICAgICAgICAgICAgd29ya19kaXI9d29ya19kaXJbOi0xXQogICAgICAgICAgICAKICAgICAgICBpZiB3b3JrX2Rpci5zdGFydHN3aXRoKCIvIik6CiAgICAgICAgICAgIHNlbGYuc2VsZi53b3JrZGlyPXdvcmtfZGlyCiAgICAgICAgZWxzZTogICAgCiAgICAgICAgICAgIHNlbGYuc2VsZi53b3JrZGlyKz0nLycrd29ya19kaXIKICAgICAgICAKICAgICAgICAjUmVtb3ZlIHJlcGVhdGVkIC8gaW4gd29ya2RpcgogICAgICAgIHNlbGYuc2VsZi53b3JrZGlyPXJlLnN1YihyJygvKVwxKycsIHInXDEnLHNlbGYuc2VsZi53b3JrZGlyKQoKICAgIGRlZiBzdGF0dXMoc2VsZik6CiAgICAgICAgaWYgb3MucGF0aC5pc2ZpbGUoc2VsZi5zZWxmLmxvZyk6CiAgICAgICAgICAgIHJldHVybiBbIlN0YXJ0ZWQiXQogICAgICAgIGVsc2U6CiAgICAgICAgICAgIHJldHVybiBbIlN0b3BwZWQiXQoKICAgIGRlZiBsb29wKHNlbGYsY29tbWFuZCxkZWxheT02MCk6CiAgICAgICAgaWYgaXNpbnN0YW5jZShjb21tYW5kLHN0cik6CiAgICAgICAgICAgIGRlZiBmdW5jKCk6CiAgICAgICAgICAgICAgICB3aGlsZSBUcnVlOgogICAgICAgICAgICAgICAgICAgIHNlbGYuc2VsZi5SdW4oY29tbWFuZCkKICAgICAgICAgICAgICAgICAgICBzZWxmLnNlbGYuV2FpdChkZWxheSkKICAgICAgICBlbHNlOgogICAgICAgICAgICBkZWYgZnVuYygpOgogICAgICAgICAgICAgICAgd2hpbGUgVHJ1ZTogIAogICAgICAgICAgICAgICAgICAgIGNvbW1hbmQoKQogICAgICAgICAgICAgICAgICAgIHNlbGYuc2VsZi5XYWl0KGRlbGF5KQogICAgICAgIHNlbGYuc2VsZi5SdW4oIiIpICNOZWVkZWQgdG8gYXZvaWQgcmFjZSBjb25kaXRpb25zIHdpdGggYSByYWNlIHRoYXQncyByaWdodCBhZnRlciAtLS0ganVzdCBydW4gc2VsZi5zZWxmLlJ1biBvbmNlCiAgICAgICAgdGhyZWFkaW5nLlRocmVhZCh0YXJnZXQ9ZnVuYyxkYWVtb249VHJ1ZSkuc3RhcnQoKQogICAgICAgCiAgICBkZWYga2lsbF9hdXhpbGlhcnlfcHJvY2Vzc2VzKHNlbGYpOgogICAgICAgIHdoaWxlIHNlbGYuc2VsZi5QcygiYXV4aWxpYXJ5IikhPVtdOiAjSWYgbmV3IHByb2Nlc3NlcyB3ZXJlIHN0YXJ0ZWQgZHVyaW5nIGFuIGl0ZXJhdGlvbiwgZ28gb3ZlciBpdCBhZ2FpbiwgdW50aWwgeW91IGtpbGxlZCB0aGVtIGFsbAogICAgICAgICAgICBmb3IgcGlkIGluIHNlbGYuc2VsZi5QcygiYXV4aWxpYXJ5Iik6CiAgICAgICAgICAgICAgICBraWxsX3Byb2Nlc3NfZ3JhY2VmdWxseShwaWQpCiAgICAgICAgICAgICAgICAKICAgIGRlZiBsb2coc2VsZik6CiAgICAgICAgc2hlbGxfY29tbWFuZChbImxlc3MiLCIrRyIsIi1mIiwiLXIiLHNlbGYuc2VsZi5sb2ddLHN0ZG91dD1Ob25lKQogICAgCiAgICBkZWYgZGVsZXRlKHNlbGYpOgogICAgICAgIHNlbGYuc2VsZi5TdG9wKCkKICAgICAgICBzaHV0aWwucm10cmVlKGYie1JPT1R9L3tzZWxmLnNlbGYubmFtZX0iKQogICAgCiAgICBkZWYgd2F0Y2goc2VsZik6CiAgICAgICAgdHJ5OgogICAgICAgICAgICBzaGVsbF9jb21tYW5kKFsidGFpbCIsIi1mIiwiLS1mb2xsb3c9bmFtZSIsc2VsZi5zZWxmLmxvZ10sc3Rkb3V0PU5vbmUpCiAgICAgICAgZXhjZXB0IEtleWJvYXJkSW50ZXJydXB0OgogICAgICAgICAgICBwYXNzCiAgICAKCg==').decode("utf-8"),utils_module.__dict__)
sys.modules["utils"]=utils_module
import subprocess
import os
import signal

import utils

import importlib.machinery, shutil
utils.GLOBALS=globals()


def flatten(*args, **kwargs):
    return utils.flatten_list(*args, **kwargs)

def print_result(*args, **kwargs):
    return utils.print_list(*args, **kwargs)

def split_by_char(*args, **kwargs):
    return utils.split_by_char(*args, **kwargs)
    
class Service:
    def __init__(self,_name,_flags=None,_env=None,_workdir='.'):
        self.Class = utils.Class(self,_name,_flags,_workdir)
        
        self.env=utils.get_value(_env,f"export SERVICE_NAME={self.name}")
        
        self.temp_services=[]
        
        self.exit_cmds=[]

    #Functions to be used in *service.py
    def Run(self,command="",pipe=False,track=True):
        with open(self.log,"a+") as log_file:
            if track:
                log_file.write(f"Command: {command}\n")
                log_file.flush()

            #Pipe output to variable
            if pipe:
                stdout=subprocess.PIPE
                stderr=subprocess.DEVNULL
            #Print output to file
            else:
                stdout=log_file
                stderr=subprocess.STDOUT
            return utils.shell_command(f"{self.env if track else 'true'}; cd {self.workdir}; {command}",stdout=stdout,stderr=stderr,arbitrary=True)
    
    def Ps(self,process=None):
        
        #Find main process
        if process=="main" or ("main" in self.flags):
            return self.Class.get_main_process()
            
        #Find processes running under main Start script
        elif process=="auxiliary" or ("auxiliary" in self.flags):
            processes=utils.shell_command(["ps","auxwwe"]).splitlines()
            processes=[_.split()[1] for _ in processes if f"SERVICE_NAME={self.name}" in _]
            return list(map(int,processes))

    
    def Env(self,*args, **kwargs):
        self.env=utils.add_environment_variable_to_string(self.env,*args, **kwargs)
    
    def Container(self,_container=None):
        #Convinence --- if conainer name is not specified, it will assume that the container is the same name as the service
        container = importlib.machinery.SourceFileLoader("gfg",shutil.which("container")).load_module()
        if not _container:
            _container=self.name
        
        _container=container.Container(_container)
        self.Down(lambda : _container.Stop())
        #self.Down(f"container stop {_container}")
        
        _container.Start()
        #self.Run(f"container start {_container}",track=False)
        
        self.Run(f"echo Started container {_container.name}",track=False)
        
        with open(self.log,"a+") as f:
            utils.shell_command(["tail","-f","-n","+1",_container.log],stdout=f,block=False,env=os.environ.copy() | {"SERVICE_NAME":self.name})
        
        container_main_pid=_container.Ps("main")[0]
        #container_main_pid=utils.shell_command(["container","ps","--main",_container],stdout=subprocess.PIPE)
        
        #Wait until container ends
        try:
            container_main_pid=int(container_main_pid)
            utils.wait_until_pid_exits(container_main_pid)
        except ValueError:
            pass
    
    def Down(self,func):
        if isinstance(func,str):
            #So func won't be overwritten
            func_str=func
            def func():
                self.Run(func_str)
        self.exit_cmds.append(func)
        
    def Loop(self,*args, **kwargs):
        self.Class.loop(*args, **kwargs)
        #Run(f'(while true; do "{command}"; sleep {delay}; done)')

    def Wait(self,*args, **kwargs):
        utils.wait(*args, **kwargs)
    
    def Exit(self,signum,frame):
        for cmd in self.exit_cmds:
            cmd()
            
        self.Class.kill_auxiliary_processes()
        
        exit()
    
    def Dependency(self,service):
        if "Stopped" in self.__class__(service).Status():
            #self.temp_services.append(service)
            #Kill service when stopping
            self.Down(self.__class__(service).Stop)
            #utils.shell_command(["service","start",service],stdout=subprocess.DEVNULL)
            self.__class__(service).Start()
    #Commands      
    def Start(self):
        
        if "Started" in self.Status():
            return f"Service {self.name} is already started"
        
        #If child, run code, then exit 
        if os.fork()==0:
            signal.signal(signal.SIGTERM,self.Exit)
            
            if os.path.exists("data"):
                self.Workdir("data")
            
            if "Enabled" in self.Status():
                service_file="service.py"
            else:
                service_file=".service.py"
                
            #Open a lock file so I can find it with lsof later
            lock_file=open(self.lock,"w+")
            
            #Run *service.py
            utils.execute(self,open(f"{ROOT}/{self.name}/{service_file}"))
            
            #Don't exit script yet.
            self.Wait()
            exit()
       
    def Stop(self):
        return [self.Class.stop()]
        
    def Restart(self):
        return self.Class.restart()
    
    
    def List(self):
        return self.Class.list()
    
    def Workdir(self,work_dir):
        self.Class.workdir(work_dir)

    def Init(self):
        os.makedirs(f"{ROOT}/{self.name}",exist_ok=True)
        os.chdir(f"{ROOT}/{self.name}")
        os.makedirs("data",exist_ok=True)
        with open(f".service.py",'a'):
            pass
        
        if 'no-edit' not in self.flags:
            self.Edit()

    def Edit(self):
        if "Enabled" in self.Status():
            utils.shell_command([os.getenv("EDITOR","vi"),f"{ROOT}/{self.name}/service.py"],stdout=None)
        else:
            utils.shell_command([os.getenv("EDITOR","vi"),f"{ROOT}/{self.name}/.service.py"],stdout=None)
            
    def Status(self):
        return self.Class.status() + ["Enabled" if os.path.exists(f"{ROOT}/{self.name}/service.py") else "Disabled"]
    
    def Enable(self):
        if "Enabled" in self.Status():
            return [f"Service {self.name} is already enabled"]
        else:
            os.rename(f"{ROOT}/{self.name}/.service.py",f"{ROOT}/{self.name}/service.py")
        
        if 'now' in self.flags:
            return [self.Start()]

            
    def Disable(self):
        if "Disabled" in self.Status():
            return [f"Service {self.name} is already disabled"]
        else:
            os.rename(f"{ROOT}/{self.name}/service.py",f"{ROOT}/{self.name}/.service.py")
        
        if 'now' in self.flags:
            return [self.Stop()]

    def Log(self):
        self.Class.log()
    
    def Delete(self):
        self.Class.delete()
    
    def Watch(self):
        self.Class.watch()
utils.CLASS=Service
utils.ROOT=ROOT=utils.get_root_directory()
if __name__ == "__main__":
    
    NAMES,FLAGS,FUNCTION=utils.extract_arguments()
    
    for name in utils.list_items_in_root(NAMES, FLAGS): 
        item=utils.CLASS(name,FLAGS)
        result=utils.execute_class_method(item,FUNCTION)
        print_result(result)
        

    
