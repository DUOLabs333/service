#!/usr/bin/env python

import subprocess

import os

import signal

import threading





import types
import sys
import base64
utils_module=types.ModuleType("utils")
sys.modules["utils"]=utils_module
setattr(utils_module,"__file__",__file__)
exec(base64.b64decode(b'aW1wb3J0IHN1YnByb2Nlc3MKCmltcG9ydCByZQoKaW1wb3J0IHRlbXBmaWxlCgppbXBvcnQgb3MKCmltcG9ydCBwYXRobGliCgppbXBvcnQgc2lnbmFsIAoKaW1wb3J0IHRpbWUKCmltcG9ydCBzeXMKCmltcG9ydCB0eXBpbmcKCmltcG9ydCBzaHV0aWwKCgoKZGVmIGdldF90ZW1wZGlyKCk6CgogICAgaWYgb3MudW5hbWUoKS5zeXNuYW1lPT0iRGFyd2luIjoKCiAgICAgICAgcmV0dXJuICIvdG1wIgoKICAgIGVsc2U6CgogICAgICAgIHJldHVybiB0ZW1wZmlsZS5nZXR0ZW1wZGlyKCkKCiAgICAKCgoKCgoKCmNsYXNzIERvZXNOb3RFeGlzdChFeGNlcHRpb24pOgoKICAgIHBhc3MKCgoKZGVmIGdldF92YWx1ZSh2YXJpYWJsZSxkZWZhdWx0KToKCglpZiBub3QgdmFyaWFibGU6CgoJCXJldHVybiBkZWZhdWx0CgoJZWxzZToKCgkJcmV0dXJuIHZhcmlhYmxlCgoKCmRlZiBnZXRfcm9vdF9kaXJlY3RvcnkoY2xhc3NfbmFtZSxyb290X3ZhcmlhYmxlPU5vbmUsZGVmYXVsdF92YWx1ZT1Ob25lKToKCiAgICByb290X3ZhcmlhYmxlPWdldF92YWx1ZShyb290X3ZhcmlhYmxlLGYie2NsYXNzX25hbWUudXBwZXIoKX1fUk9PVCIpCgogICAgZGVmYXVsdF92YWx1ZT1nZXRfdmFsdWUoZGVmYXVsdF92YWx1ZSxmIntvcy5lbnZpcm9uWydIT01FJ119L3tjbGFzc19uYW1lLnRpdGxlKCl9cyIpCgogICAgcmV0dXJuIG9zLnBhdGguZXhwYW5kdXNlcihvcy5nZXRlbnYocm9vdF92YXJpYWJsZSxkZWZhdWx0X3ZhbHVlKSkKCiAgICAKClJPT1Q9Tm9uZQoKTkFNRVM9Tm9uZQoKRkxBR1M9Tm9uZQoKRlVOQ1RJT049Tm9uZQoKVEVNUERJUj1Ob25lCgoKCmRlZiBsaXN0X2l0ZW1zX2luX3Jvb3QobmFtZXMsZmxhZ3MsY2xhc3NfbmFtZSk6CgogICAgQWxsPVtfIGZvciBfIGluIHNvcnRlZChvcy5saXN0ZGlyKFJPT1QpKSBpZiBub3QgXy5zdGFydHN3aXRoKCcuJykgXQoKICAgIHByaW50KEFsbCkKCiAgICBpZiAiLS1zdGFydGVkIiBpbiBmbGFnczoKCiAgICAgICAgbmFtZXMrPVtfIGZvciBfIGluIEFsbCBpZiAiU3RhcnRlZCIgaW4gZXZhbChmIntjbGFzc19uYW1lfShfKS5TdGF0dXMoKSIpIF0KCiAgICAgICAgZmxhZ3MucmVtb3ZlKCItLXN0YXJ0ZWQiKQoKICAgIGlmICItLXN0b3BwZWQiIGluIGZsYWdzOgoKICAgICAgICBuYW1lcys9W18gZm9yIF8gaW4gQWxsIGlmICJTdG9wcGVkIiBpbiBldmFsKGYie2NsYXNzX25hbWV9KF8pLlN0YXR1cygpIikgXQoKICAgICAgICBmbGFncy5yZW1vdmUoIi0tc3RvcHBlZCIpCgogICAgaWYgIi0tZW5hYmxlZCIgaW4gZmxhZ3M6CgogICAgICAgIG5hbWVzKz1bXyBmb3IgXyBpbiBBbGwgaWYgIkVuYWJsZWQiIGluIGV2YWwoZiJ7Y2xhc3NfbmFtZX0oXykuU3RhdHVzKCkiKSBdCgogICAgICAgIGZsYWdzLnJlbW92ZSgiLS1lbmFibGVkIikKCiAgICAKCiAgICBpZiAiLS1kaXNhYmxlZCIgaW4gZmxhZ3M6CgogICAgICAgIG5hbWVzKz1bXyBmb3IgXyBpbiBBbGwgaWYgIkRpc2FibGVkIiBpbiBldmFsKGYie2NsYXNzX25hbWV9KF8pLlN0YXR1cygpIikgXQoKICAgICAgICBmbGFncy5yZW1vdmUoIi0tZGlzYWJsZWQiKQoKCgogICAgaWYgIi0tYWxsIiBpbiBmbGFnczoKCiAgICAgICAgbmFtZXMrPUFsbAoKICAgICAgICBmbGFncy5yZW1vdmUoIi0tYWxsIikKCiAgICBpZiBuYW1lcz09W106CgogICAgICAgIHByaW50KGYiTm8ge2NsYXNzX25hbWV9cyBzcGVjaWZpZWQhIikKCiAgICAgICAgZXhpdCgpCgogICAgcmV0dXJuIG5hbWVzCgoKCmRlZiBmbGF0dGVuX2xpc3QoaXRlbXMpOgoKICAgICIiIllpZWxkIGl0ZW1zIGZyb20gYW55IG5lc3RlZCBpdGVyYWJsZS4iIiIKCiAgICBmb3IgeCBpbiBpdGVtczoKCiAgICAgICAgaWYgaXNpbnN0YW5jZSh4LCB0eXBpbmcuSXRlcmFibGUpIGFuZCBub3QgaXNpbnN0YW5jZSh4LCAoc3RyLCBieXRlcykpOgoKICAgICAgICAgICAgZm9yIHN1Yl94IGluIGZsYXR0ZW5fbGlzdCh4KToKCiAgICAgICAgICAgICAgICB5aWVsZCBzdWJfeAoKICAgICAgICBlbHNlOgoKICAgICAgICAgICAgeWllbGQgeAoKCgpkZWYgcHJpbnRfbGlzdChsKToKCiAgICBmb3IgZWxlbWVudCBpbiBsOgoKICAgICAgICBpZiBlbGVtZW50IGlzIE5vbmU6CgogICAgICAgICAgICBwcmludChlbmQ9JycpCgogICAgICAgIGVsc2U6CgogICAgICAgICAgICBwcmludChlbGVtZW50KQoKCgpkZWYgc3BsaXRfc3RyaW5nX2J5X2NoYXIoc3RyaW5nLGNoYXI9JzonKToKCiAgICBQQVRURVJOID0gcmUuY29tcGlsZShyZicnJygoPzpbXlx7Y2hhcn0iJ118IlteIl0qInwnW14nXSonKSspJycnKQoKICAgIHJldHVybiBbXyBmb3IgXyBpbiBsaXN0KFBBVFRFUk4uc3BsaXQoc3RyaW5nKSkgaWYgXyBub3QgaW4gWycnLCBjaGFyXV0KCgoKCgpkZWYgc2hlbGxfY29tbWFuZChjb21tYW5kLHN0ZG91dD1zdWJwcm9jZXNzLlBJUEUsc3RkZXJyPXN1YnByb2Nlc3MuU1RET1VULGFyYml0cmFyeT1GYWxzZSxibG9jaz1UcnVlKToKCiAgICBwcm9jZXNzID0gc3VicHJvY2Vzcy5Qb3Blbihjb21tYW5kLCBzdGRvdXQ9c3Rkb3V0LCBzdGRlcnI9c3RkZXJyLHVuaXZlcnNhbF9uZXdsaW5lcz1UcnVlLHNoZWxsPWFyYml0cmFyeSkKCiAgICBpZiBibG9jazoKCiAgICAgICAgcmV0dXJuIHByb2Nlc3MuY29tbXVuaWNhdGUoKVswXQoKCgoKCgoKCgpkZWYgZXh0cmFjdF9hcmd1bWVudHMoKToKCiAgICBhcmd1bWVudHM9c3lzLmFyZ3ZbMTpdCgogICAgdHJ5OgoKICAgICAgICBGVU5DVElPTj1hcmd1bWVudHNbMF0KCiAgICBleGNlcHQgSW5kZXhFcnJvcjoKCiAgICAgICAgcHJpbnQoIk5vIGZ1bmN0aW9uIHNwZWNpZmllZCEiKQoKICAgICAgICBleGl0KCkKCiAgICBhcmd1bWVudHM9YXJndW1lbnRzWzE6XQoKICAgIAoKICAgIE5BTUVTPVtdCgogICAgRkxBR1M9YXJndW1lbnRzCgogICAgZm9yIGkgaW4gcmFuZ2UobGVuKGFyZ3VtZW50cykpOgoKICAgICAgICBpZiBub3QgYXJndW1lbnRzW2ldLnN0YXJ0c3dpdGgoIi0tIik6CgogICAgICAgICAgICBGTEFHUz1hcmd1bWVudHNbOmldCgogICAgICAgICAgICBOQU1FUz1hcmd1bWVudHNbaTpdCgogICAgICAgICAgICBicmVhawoKICAgIHJldHVybiAoTkFNRVMsRkxBR1MsRlVOQ1RJT04pCgoKCmRlZiBhZGRfZW52aXJvbm1lbnRfdmFyaWFibGVfdG9fc3RyaW5nKHN0cmluZyxlbnZfdmFyKToKCiAgICByZXR1cm4gc3RyaW5nK2YiOyBleHBvcnQge2Vudl92YXJ9IgoKCgpkZWYgd2FpdChkZWxheT1Ob25lKToKCiAgICBpZiBub3QgZGVsYXk6CgogICAgICAgIHNpZ25hbC5wYXVzZSgpCgogICAgZWxzZToKCiAgICAgICAgdGltZS5zbGVlcChpbnQoZGVsYXkpKQoKCgpkZWYgZXhlY3V0ZV9jbGFzc19tZXRob2QoY2xhc3NfaW5zdGFuY2UsZnVuY3Rpb24pOgoKICAgIGlmIG5vdCBjYWxsYWJsZShnZXRhdHRyKGNsYXNzX2luc3RhbmNlLCBmdW5jdGlvbi50aXRsZSgpLE5vbmUpKToKCiAgICAgICAgICAgIHByaW50KGYiQ29tbWFuZCB7ZnVuY3Rpb259IGRvZXNuJ3QgZXhpc3QhIikKCiAgICAgICAgICAgIGV4aXQoKQoKICAgIGVsc2U6CgogICAgICAgIHJldHVybiBsaXN0KGZsYXR0ZW5fbGlzdChbZ2V0YXR0cihjbGFzc19pbnN0YW5jZSxmdW5jdGlvbi50aXRsZSgpKSgpXSkpCgoKCmRlZiBleHBvcnRfbWV0aG9kc19nbG9iYWxseShjbGFzc19pbnN0YW5jZV9zdHJpbmcsZ2xvYmFsc19kaWN0KToKCiAgICBDbGFzcz1ldmFsKGYie2NsYXNzX2luc3RhbmNlX3N0cmluZ30uX19jbGFzc19fIixnbG9iYWxzX2RpY3QpCgogICAgZm9yIGZ1bmMgaW4gW2Z1bmMgZm9yIGZ1bmMgaW4gZGlyKENsYXNzKSBpZiBjYWxsYWJsZShnZXRhdHRyKENsYXNzLCBmdW5jKSkgYW5kIG5vdCBmdW5jLnN0YXJ0c3dpdGgoJ19fJyldOgoKICAgICAgICBleGVjKGYiZ2xvYmFsIHtmdW5jfSIsZ2xvYmFsc19kaWN0KQoKICAgICAgICBleGVjKGYie2Z1bmN9ID0ge2NsYXNzX2luc3RhbmNlX3N0cmluZ30ue2Z1bmN9IixnbG9iYWxzX2RpY3QpCgoKCmNsYXNzIENsYXNzOgoKICAgIGRlZiBfX2luaXRfXyhzZWxmLGNsYXNzX3NlbGYsY2xhc3NfbmFtZSk6CgogICAgICAgIHNlbGYuc2VsZj1jbGFzc19zZWxmCgogICAgICAgIHNlbGYubmFtZT1jbGFzc19uYW1lCgogICAgCgogICAgZGVmIGNsYXNzX2luaXQoc2VsZixfbmFtZSxfZmxhZ3M9Tm9uZSxfZnVuY3Rpb249Tm9uZSk6CgogICAgICAgIHNlbGYuc2VsZi5uYW1lPV9uYW1lCgogICAgICAgIAoKICAgICAgICBzZWxmLnNlbGYuZmxhZ3M9Z2V0X3ZhbHVlKF9mbGFncyxGTEFHUykKCiAgICAgICAgCgogICAgICAgIHNlbGYuc2VsZi5mdW5jdGlvbj1nZXRfdmFsdWUoX2Z1bmN0aW9uLEZVTkNUSU9OKQoKICAgICAgICAKCiAgICAgICAgaWYgc2VsZi5zZWxmLmZ1bmN0aW9uIG5vdCBpbiBbImluaXQiXToKCiAgICAgICAgICAgIGlmIG5vdCBvcy5wYXRoLmlzZGlyKGYie1JPT1R9L3tzZWxmLnNlbGYubmFtZX0iKToKCiAgICAgICAgICAgICAgICAgcmFpc2UgRG9lc05vdEV4aXN0KCkKCiAgICAgICAgICAgICAgICAgcmV0dXJuCgogICAgICAgICAgICBvcy5jaGRpcihmIntST09UfS97c2VsZi5zZWxmLm5hbWV9IikKCiAgICBkZWYgc3RvcChzZWxmKToKCiAgICAgICAgaWYgIlN0b3BwZWQiIGluIHNlbGYuc2VsZi5TdGF0dXMoKToKCiAgICAgICAgICAgIHJldHVybiBmIlNlcnZpY2Uge3NlbGYuc2VsZi5uYW1lfSBpcyBhbHJlYWR5IHN0b3BwZWQiCgogICAgICAgIAoKICAgICAgICBmb3IgcHJvY2VzcyBpbiBbIm1haW4iLCAiYXV4aWxpYXJ5Il06CgogICAgICAgICAgICBmb3IgcGlkIGluIHNlbGYuc2VsZi5Qcyhwcm9jZXNzKToKCiAgICAgICAgICAgICAgICBvcy5raWxsKHBpZCxzaWduYWwuU0lHVEVSTSkKCiAgICAgICAgCgogICAgZGVmIGNsZWFudXBfYWZ0ZXJfc3RvcChzZWxmKToKCiAgICAgICAgZm9yIGVuZGluZyBpbiBbImxvZyIsImxvY2siXToKCiAgICAgICAgICAgIHRyeToKCiAgICAgICAgICAgICAgIG9zLnJlbW92ZShmIntURU1QRElSfS97c2VsZi5uYW1lfV97c2VsZi5zZWxmLm5hbWV9LntlbmRpbmd9IikKCiAgICAgICAgICAgIGV4Y2VwdCBGaWxlTm90Rm91bmRFcnJvcjoKCiAgICAgICAgICAgICAgICBwYXNzCgoKCiAgICBkZWYgcmVzdGFydChzZWxmKToKCiAgICAgICAgcmV0dXJuIFtzZWxmLnNlbGYuU3RvcCgpLHNlbGYuc2VsZi5TdGFydCgpXQoKICAgIAoKICAgIGRlZiBnZXRfbWFpbl9wcm9jZXNzKHNlbGYpOgoKICAgICAgICBpZiBub3Qgb3MucGF0aC5pc2ZpbGUoZiJ7VEVNUERJUn0ve3NlbGYubmFtZX1fe3NlbGYuc2VsZi5uYW1lfS5sb2NrIik6CgogICAgICAgICAgICAgICAgcmV0dXJuIFtdCgogICAgICAgIGVsc2U6CgogICAgICAgICAgICByZXR1cm4gbGlzdChtYXAoaW50LFtfWzE6XSBmb3IgXyBpbiBzaGVsbF9jb21tYW5kKFsibHNvZiIsIi1GcCIsIi13IixmIntURU1QRElSfS97c2VsZi5uYW1lfV97c2VsZi5zZWxmLm5hbWV9LmxvY2siXSkuc3BsaXRsaW5lcygpXSkpCgogICAgCgogICAgZGVmIGxpc3Qoc2VsZik6CgogICAgICAgIHJldHVybiBzZWxmLnNlbGYubmFtZQoKCgogICAgZGVmIGVkaXQoc2VsZik6CgogICAgICAgIGlmICJFbmFibGVkIiBpbiBzZWxmLnNlbGYuU3RhdHVzKCk6CgogICAgICAgICAgICBTaGVsbChbb3MuZ2V0ZW52KCJFRElUT1IiLCJ2aSIpLGYie1JPT1R9L3tzZWxmLnNlbGYubmFtZX0ve3NlbGYubmFtZX0ucHkiXSxzdGRvdXQ9Tm9uZSkKCiAgICAgICAgZWxzZToKCiAgICAgICAgICAgIFNoZWxsKFtvcy5nZXRlbnYoIkVESVRPUiIsInZpIiksZiJ7Uk9PVH0ve3NlbGYuc2VsZi5uYW1lfS8ue3NlbGYubmFtZX0ucHkiXSxzdGRvdXQ9Tm9uZSkKCgoKICAgIGRlZiBzdGF0dXMoc2VsZik6CgogICAgICAgIHN0YXR1cz1bXQoKICAgICAgICBpZiBvcy5wYXRoLmlzZmlsZShmIntURU1QRElSfS97c2VsZi5uYW1lfV97c2VsZi5zZWxmLm5hbWV9LmxvZyIpOgoKICAgICAgICAgICAgc3RhdHVzKz1bIlN0YXJ0ZWQiXQoKICAgICAgICBlbHNlOgoKICAgICAgICAgICAgc3RhdHVzKz1bIlN0b3BwZWQiXQoKICAgICAgICAKCiAgICAgICAgaWYgb3MucGF0aC5leGlzdHMoZiJ7Uk9PVH0ve3NlbGYuc2VsZi5uYW1lfS97c2VsZi5uYW1lfS5weSIpOgoKICAgICAgICAgICAgc3RhdHVzKz1bIkVuYWJsZWQiXQoKICAgICAgICBlbHNlOgoKICAgICAgICAgICAgc3RhdHVzKz1bIkRpc2FibGVkIl0KCiAgICAgICAgcmV0dXJuIHN0YXR1cwoKICAgIAoKICAgIGRlZiBlbmFibGUoc2VsZik6CgogICAgICAgIGlmICJFbmFibGVkIiBpbiBzZWxmLnNlbGYuU3RhdHVzKCk6CgogICAgICAgICAgICByZXR1cm4gW2Yie3NlbGYubmFtZX0gaXMgYWxyZWFkeSBlbmFibGVkIl0KCiAgICAgICAgZWxzZToKCiAgICAgICAgICAgIG9zLnJlbmFtZShmIntST09UfS97c2VsZi5zZWxmLm5hbWV9Ly57c2VsZi5uYW1lfS5weSIsZiJ7Uk9PVH0ve3NlbGYuc2VsZi5uYW1lfS97c2VsZi5uYW1lfS5weSIpCgogICAgICAgIAoKICAgICAgICBpZiAnLS1ub3cnIGluIHNlbGYuc2VsZi5mbGFnczoKCiAgICAgICAgICAgIHJldHVybiBbc2VsZi5zZWxmLlN0YXJ0KCldCgoKCiAgICAgICAgICAgIAoKICAgIGRlZiBkaXNhYmxlKHNlbGYpOgoKICAgICAgICBpZiAiRGlzYWJsZWQiIGluIHNlbGYuc2VsZi5TdGF0dXMoKToKCiAgICAgICAgICAgIHJldHVybiBbZiJ7c2VsZi5zZWxmLm5hbWV9IGlzIGFscmVhZHkgZGlzYWJsZWQiXQoKICAgICAgICBlbHNlOgoKICAgICAgICAgICAgb3MucmVuYW1lKGYie1JPT1R9L3tzZWxmLnNlbGYubmFtZX0ve3NlbGYubmFtZX0ucHkiLGYie1JPT1R9L3tzZWxmLnNlbGYubmFtZX0vLntzZWxmLm5hbWV9LnB5IikKCiAgICAgICAgCgogICAgICAgIGlmICctLW5vdycgaW4gc2VsZi5zZWxmLmZsYWdzOgoKICAgICAgICAgICAgcmV0dXJuIFtzZWxmLnNlbGYuU3RvcCgpXQoKCgogICAgZGVmIGxvZyhzZWxmKToKCiAgICAgICAgc2hlbGxfY29tbWFuZChbImxlc3MiLCIrRyIsZiJ7VEVNUERJUn0ve3NlbGYubmFtZX1fe3NlbGYuc2VsZi5uYW1lfS5sb2ciXSxzdGRvdXQ9Tm9uZSkKCiAgICAKCiAgICBkZWYgZGVsZXRlKHNlbGYpOgoKICAgICAgICBzZWxmLnNlbGYuU3RvcCgpCgogICAgICAgIHNodXRpbC5ybXRyZWUoc2VsZi5zZWxmLm5hbWUpCgogICAgCgogICAgZGVmIHdhdGNoKHNlbGYpOgoKICAgICAgICBzaGVsbF9jb21tYW5kKFsidGFpbCIsIi1mIixmIntURU1QRElSfS97c2VsZi5uYW1lfV97c2VsZi5zZWxmLm5hbWV9LmxvZyJdLHN0ZG91dD1Ob25lKQoKCg==').decode("utf-8"),utils_module.__dict__)




import utils



CLASS_NAME="Service"

utils.ROOT=ROOT=utils.get_root_directory(CLASS_NAME)

utils.TEMPDIR=TEMPDIR=utils.get_tempdir()



NAMES,FLAGS,FUNCTION=utils.extract_arguments()



utils.NAMES=NAMES

utils.FLAGS=FLAGS

utils.ROOT=ROOT



SHELL=os.getenv('SHELL','bash')

SHELL_CWD=os.environ.get("PWD")



def list_services(*args, **kwargs):

    return utils.list_items_in_root(*args, FLAGS,CLASS_NAME,**kwargs)    



def flatten(*args, **kwargs):

    return utils.flatten_list(*args, **kwargs)



def print_result(*args, **kwargs):

    return utils.print_list(*args, **kwargs)



def split_by_char(*args, **kwargs):

    return utils.split_by_char(*args, **kwargs)

    

def Shell(*args, **kwargs):

    return utils.shell_command(*args, **kwargs)





ServiceDoesNotExist=utils.DoesNotExist

    

class Service:

    def __init__(self,_name,_flags=None,_function=None,_env=None):

        self.Class = utils.Class(self,CLASS_NAME.lower())

        self.Class.class_init(_name,_flags,_function)

        

        self.env=utils.get_value(_env,f"export SERVICE_NAME={self.name}")

    

    #Functions to be used in *service.py

    def Run(self,command="",pipe=False):

        with open(f"{TEMPDIR}/service_{self.name}.log","a+") as log_file:

            log_file.write(f"Command: {command}\n")

            log_file.flush()



            #Pipe output to variable

            if pipe:

                stdout=subprocess.PIPE

                stderr=subprocess.DEVNULL

            #Print output to file

            else:

                stdout=log_file

                stderr=subprocess.STDOUT

            return Shell(f"{self.env}; {command}",stdout=stdout,stderr=stderr,arbitrary=True)

    

    def Ps(self,process="auxiliary"):

        

        #Find main process

        if process=="main":

            return self.Class.get_main_process()

            

        #Find processes running under main Start script

        elif process=="auxiliary":

            processes=Shell(["ps","auwwe"]).splitlines()

            processes=[_.split()[1] for _ in processes if f"SERVICE_NAME={self.name}" in _]

            return list(map(int,processes))



    

    def Env(self,*args, **kwargs):

        self.env=utils.add_environment_variable_to_string(self.env,*args, **kwargs)

    

    def Container(self,_container=None):

        #Convience --- if conainer name is not specified, it will assume that the container is the same name as the service

        

        if not _container:

            _container=self.name

            

        self.Down(f"container stop {_container}; sleep 1")

        self.Run(f"container start {_container}")

        

        #Wait 2 seconds before beginning

        self.Wait(2)

        with open(f"{TEMPDIR}/service_{self.name}.log","a+") as f:

            Shell(["tail","-f","-n","+1",f"{TEMPDIR}/container_{_container}.log"],stdout=f,block=False)

    

    def Down(self,func):

        #Yes, this decorator stuff is absolutely neccessary, anything else will not work

    

        if isinstance(func,str):

            #So func won't be overwritten

            func_str=func

            def func():

                Shell(func_str,arbitrary=True)

        def decorator_Exit(exit_func):

            def new_Exit(*args, **kwargs):

                #So exit() is the last function run

                func()

                exit_func(*args, **kwargs)

            return new_Exit

        self.Exit=decorator_Exit(self.Exit)

        signal.signal(signal.SIGTERM,self.Exit)

        

    def Loop(self,command,delay=60):

        if isinstance(command,str):

            def func():

                while True:

                    Run(command)

                    self.Wait(delay)

        else:

            def func():

                while True:  

                    command()

                    self.Wait(delay)

        threading.Thread(target=func).start()



    def Wait(self,*args, **kwargs):

        utils.wait(*args, **kwargs)

    

    def Exit(self,signum,frame):

        exit()

        

    #Commands      

    def Start(self):

        

        if "Started" in self.Status():

            return f"Service {self.name} is already started"

        

        if os.path.exists("data"):

            os.chdir("data")

        

        if "Enabled" in self.Status():

            service_file="service.py"

        else:

            service_file=".service.py"

        

        #Fork process, so it can run in the background

        pid=os.fork()

        

        #If child, run code, then exit 

        if pid==0:

            #Open a lock file so I can find it with lsof later

            signal.signal(signal.SIGTERM,self.Exit)

            lock_file=open(f"{TEMPDIR}/service_{self.name}.lock","w+")

            

            #Run *service.py

            with open(f"{ROOT}/{self.name}/{service_file}") as f:

                code=f.read()

            exec(code,globals(),locals())

            

            #Don't exit script yet.

            self.Wait()

            exit()

       

    def Stop(self):

        output=[self.Class.stop()]

        self.Class.cleanup_after_stop()

        return output

        

    def Restart(self):

        return self.Class.restart()

    

    

    def List(self):

        return self.Class.list()



    def Init(self):

        os.makedirs(f"{ROOT}/{self.self.name}",exist_ok=True)

        os.chdir(f"{ROOT}/{self.self.name}")

        os.makedirs("data",exist_ok=True)

        with open(f".{self.name}.py",'a'):

            pass

        

        if '--no-edit' not in self.flags:

            self.self.Edit()



    def Edit(self):

        self.Class.edit()

    def Status(self):

        return self.Class.status()

    

    def Enable(self):

        return self.Class.enable()



            

    def Disable(self):

        return self.Class.disable()



    def Log(self):

        self.Class.log()

    

    def Delete(self):

        self.Class.stop()

    

    def Watch(self):

        self.Class.watch()





exec(f"utils.{CLASS_NAME}={CLASS_NAME}")

NAMES=list_services(NAMES)

for name in NAMES: 

    try:

        service=Service(name,FLAGS)

    except ServiceDoesNotExist:

        print(f"Service {name} does not exist")

        continue

    

    utils.export_methods_globally(CLASS_NAME.lower(),globals())

    

    result=utils.execute_class_method(eval(f"{CLASS_NAME.lower()}"),FUNCTION)

    print_result(result)

        



    
