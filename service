#!/usr/bin/env python
import subprocess
import os
import signal
import threading



import types
import sys
import base64
utils_module=types.ModuleType("utils")
#setattr(utils_module,"__file__",__file__)
exec(base64.b64decode(b'aW1wb3J0IHN1YnByb2Nlc3MKaW1wb3J0IHJlCmltcG9ydCB0ZW1wZmlsZQppbXBvcnQgb3MKaW1wb3J0IHBhdGhsaWIKaW1wb3J0IHNpZ25hbCAKaW1wb3J0IHRpbWUKaW1wb3J0IHN5cwppbXBvcnQgdHlwaW5nCmltcG9ydCBzaHV0aWwKaW1wb3J0IHRocmVhZGluZwoKZGVmIGdldF90ZW1wZGlyKCk6CiAgICBpZiBvcy51bmFtZSgpLnN5c25hbWU9PSJEYXJ3aW4iOgogICAgICAgIHJldHVybiAiL3RtcCIKICAgIGVsc2U6CiAgICAgICAgcmV0dXJuIHRlbXBmaWxlLmdldHRlbXBkaXIoKQogICAgCgoKCmNsYXNzIERvZXNOb3RFeGlzdChFeGNlcHRpb24pOgogICAgcGFzcwoKZGVmIGdldF92YWx1ZSh2YXJpYWJsZSxkZWZhdWx0KToKCWlmIG5vdCB2YXJpYWJsZToKCQlyZXR1cm4gZGVmYXVsdAoJZWxzZToKCQlyZXR1cm4gdmFyaWFibGUKCmRlZiBnZXRfcm9vdF9kaXJlY3RvcnkoY2xhc3NfbmFtZSxyb290X3ZhcmlhYmxlPU5vbmUsZGVmYXVsdF92YWx1ZT1Ob25lKToKICAgIHJvb3RfdmFyaWFibGU9Z2V0X3ZhbHVlKHJvb3RfdmFyaWFibGUsZiJ7Y2xhc3NfbmFtZS51cHBlcigpfV9ST09UIikKICAgIGRlZmF1bHRfdmFsdWU9Z2V0X3ZhbHVlKGRlZmF1bHRfdmFsdWUsZiJ7b3MuZW52aXJvblsnSE9NRSddfS97Y2xhc3NfbmFtZS50aXRsZSgpfXMiKQogICAgcmV0dXJuIG9zLnBhdGguZXhwYW5kdXNlcihvcy5nZXRlbnYocm9vdF92YXJpYWJsZSxkZWZhdWx0X3ZhbHVlKSkKCmZvciB2YXIgaW4gWyJST09UIiwgIk5BTUVTIiwiVEVNUERJUiJdOgogICAgZ2xvYmFscygpW3Zhcl09Tm9uZSAgCiAgICAKI1JPT1Q9Tm9uZQojTkFNRVM9Tm9uZQojRkxBR1M9Tm9uZQojRlVOQ1RJT049Tm9uZQojVEVNUERJUj1Ob25lCgpkZWYgbGlzdF9pdGVtc19pbl9yb290KG5hbWVzLGZsYWdzLGNsYXNzX25hbWUpOgogICAgQWxsPVtfIGZvciBfIGluIHNvcnRlZChvcy5saXN0ZGlyKFJPT1QpKSBpZiBub3QgXy5zdGFydHN3aXRoKCcuJykgXQogICAgaWYgIi0tc3RhcnRlZCIgaW4gZmxhZ3M6CiAgICAgICAgbmFtZXMrPVtfIGZvciBfIGluIEFsbCBpZiAiU3RhcnRlZCIgaW4gZXZhbChmIntjbGFzc19uYW1lfShfKS5TdGF0dXMoKSIpIF0KICAgICAgICBmbGFncy5yZW1vdmUoIi0tc3RhcnRlZCIpCiAgICBpZiAiLS1zdG9wcGVkIiBpbiBmbGFnczoKICAgICAgICBuYW1lcys9W18gZm9yIF8gaW4gQWxsIGlmICJTdG9wcGVkIiBpbiBldmFsKGYie2NsYXNzX25hbWV9KF8pLlN0YXR1cygpIikgXQogICAgICAgIGZsYWdzLnJlbW92ZSgiLS1zdG9wcGVkIikKICAgIGlmICItLWVuYWJsZWQiIGluIGZsYWdzOgogICAgICAgIG5hbWVzKz1bXyBmb3IgXyBpbiBBbGwgaWYgIkVuYWJsZWQiIGluIGV2YWwoZiJ7Y2xhc3NfbmFtZX0oXykuU3RhdHVzKCkiKSBdCiAgICAgICAgZmxhZ3MucmVtb3ZlKCItLWVuYWJsZWQiKQogICAgCiAgICBpZiAiLS1kaXNhYmxlZCIgaW4gZmxhZ3M6CiAgICAgICAgbmFtZXMrPVtfIGZvciBfIGluIEFsbCBpZiAiRGlzYWJsZWQiIGluIGV2YWwoZiJ7Y2xhc3NfbmFtZX0oXykuU3RhdHVzKCkiKSBdCiAgICAgICAgZmxhZ3MucmVtb3ZlKCItLWRpc2FibGVkIikKCiAgICBpZiAiLS1hbGwiIGluIGZsYWdzOgogICAgICAgIG5hbWVzKz1BbGwKICAgICAgICBmbGFncy5yZW1vdmUoIi0tYWxsIikKICAgIGlmIG5hbWVzPT1bXToKICAgICAgICBwcmludChmIk5vIHtjbGFzc19uYW1lfXMgc3BlY2lmaWVkISIpCiAgICAgICAgZXhpdCgpCiAgICByZXR1cm4gbmFtZXMKCmRlZiBmbGF0dGVuX2xpc3QoaXRlbXMpOgogICAgIiIiWWllbGQgaXRlbXMgZnJvbSBhbnkgbmVzdGVkIGl0ZXJhYmxlLiIiIgogICAgZm9yIHggaW4gaXRlbXM6CiAgICAgICAgaWYgaXNpbnN0YW5jZSh4LCB0eXBpbmcuSXRlcmFibGUpIGFuZCBub3QgaXNpbnN0YW5jZSh4LCAoc3RyLCBieXRlcykpOgogICAgICAgICAgICBmb3Igc3ViX3ggaW4gZmxhdHRlbl9saXN0KHgpOgogICAgICAgICAgICAgICAgeWllbGQgc3ViX3gKICAgICAgICBlbHNlOgogICAgICAgICAgICB5aWVsZCB4CgpkZWYgcHJpbnRfbGlzdChsKToKICAgIGZvciBlbGVtZW50IGluIGw6CiAgICAgICAgaWYgZWxlbWVudCBpcyBOb25lOgogICAgICAgICAgICBwcmludChlbmQ9JycpCiAgICAgICAgZWxzZToKICAgICAgICAgICAgcHJpbnQoZWxlbWVudCkKCmRlZiBzcGxpdF9zdHJpbmdfYnlfY2hhcihzdHJpbmcsY2hhcj0nOicpOgogICAgUEFUVEVSTiA9IHJlLmNvbXBpbGUocmYnJycoKD86W15ce2NoYXJ9IiddfCJbXiJdKiJ8J1teJ10qJykrKScnJykKICAgIHJldHVybiBbXyBmb3IgXyBpbiBsaXN0KFBBVFRFUk4uc3BsaXQoc3RyaW5nKSkgaWYgXyBub3QgaW4gWycnLCBjaGFyXV0KCgpkZWYgc2hlbGxfY29tbWFuZChjb21tYW5kLHN0ZG91dD1zdWJwcm9jZXNzLlBJUEUsc3RkZXJyPXN1YnByb2Nlc3MuU1RET1VULGFyYml0cmFyeT1GYWxzZSxibG9jaz1UcnVlKToKICAgIHByb2Nlc3MgPSBzdWJwcm9jZXNzLlBvcGVuKGNvbW1hbmQsIHN0ZG91dD1zdGRvdXQsIHN0ZGVycj1zdGRlcnIsdW5pdmVyc2FsX25ld2xpbmVzPVRydWUsc2hlbGw9YXJiaXRyYXJ5KQogICAgaWYgYmxvY2s6CiAgICAgICAgcmV0dXJuIHByb2Nlc3MuY29tbXVuaWNhdGUoKVswXQoKCmRlZiBjaGVja19waWQocGlkKTogICAgICAgIAogICAgIiIiIENoZWNrIEZvciB0aGUgZXhpc3RlbmNlIG9mIGEgdW5peCBwaWQuICIiIgogICAgdHJ5OgogICAgICAgIG9zLmtpbGwocGlkLCAwKQogICAgZXhjZXB0IE9TRXJyb3I6CiAgICAgICAgcmV0dXJuIEZhbHNlCiAgICBlbHNlOgogICAgICAgIHJldHVybiBUcnVlCgpkZWYgZXh0cmFjdF9hcmd1bWVudHMoKToKICAgIGFyZ3VtZW50cz1zeXMuYXJndlsxOl0KICAgIHRyeToKICAgICAgICBGVU5DVElPTj1hcmd1bWVudHNbMF0KICAgIGV4Y2VwdCBJbmRleEVycm9yOgogICAgICAgIHByaW50KCJObyBmdW5jdGlvbiBzcGVjaWZpZWQhIikKICAgICAgICBleGl0KCkKICAgIGFyZ3VtZW50cz1hcmd1bWVudHNbMTpdCiAgICAKICAgIE5BTUVTPVtdCiAgICBGTEFHUz1hcmd1bWVudHMKICAgIGZvciBpIGluIHJhbmdlKGxlbihhcmd1bWVudHMpKToKICAgICAgICBpZiBub3QgYXJndW1lbnRzW2ldLnN0YXJ0c3dpdGgoIi0tIik6CiAgICAgICAgICAgIEZMQUdTPWFyZ3VtZW50c1s6aV0KICAgICAgICAgICAgTkFNRVM9YXJndW1lbnRzW2k6XQogICAgICAgICAgICBicmVhawogICAgcmV0dXJuIChOQU1FUyxGTEFHUyxGVU5DVElPTikKCmRlZiBhZGRfZW52aXJvbm1lbnRfdmFyaWFibGVfdG9fc3RyaW5nKHN0cmluZyxlbnZfdmFyKToKICAgIHJldHVybiBzdHJpbmcrZiI7IGV4cG9ydCB7ZW52X3Zhcn0iCgpkZWYgd2FpdChkZWxheT1Ob25lKToKICAgIHRocmVhZGluZy5FdmVudCgpLndhaXQodGltZW91dD1kZWxheSkKCmRlZiBleGVjdXRlX2NsYXNzX21ldGhvZChjbGFzc19pbnN0YW5jZSxmdW5jdGlvbik6CiAgICBpZiBub3QgY2FsbGFibGUoZ2V0YXR0cihjbGFzc19pbnN0YW5jZSwgZnVuY3Rpb24udGl0bGUoKSxOb25lKSk6CiAgICAgICAgICAgIHByaW50KGYiQ29tbWFuZCB7ZnVuY3Rpb259IGRvZXNuJ3QgZXhpc3QhIikKICAgICAgICAgICAgZXhpdCgpCiAgICBlbHNlOgogICAgICAgIHJldHVybiBsaXN0KGZsYXR0ZW5fbGlzdChbZ2V0YXR0cihjbGFzc19pbnN0YW5jZSxmdW5jdGlvbi50aXRsZSgpKSgpXSkpCgpkZWYgZXhwb3J0X21ldGhvZHNfZ2xvYmFsbHkoY2xhc3NfbmFtZSxnbG9iYWxzX2RpY3QpOgogICAgZXhlYyhmInV0aWxzLntjbGFzc19uYW1lfT17Y2xhc3NfbmFtZX0iLGdsb2JhbHNfZGljdCkKICAgIGZvciBmdW5jIGluIFtmdW5jIGZvciBmdW5jIGluIGRpcihldmFsKGNsYXNzX25hbWUpKSBpZiBjYWxsYWJsZShnZXRhdHRyKGV2YWwoY2xhc3NfbmFtZSksIGZ1bmMpKSBhbmQgbm90IGZ1bmMuc3RhcnRzd2l0aCgnX18nKV06CiAgICAgICAgZXhlYyhmImdsb2JhbCB7ZnVuY30iLGdsb2JhbHNfZGljdCkKICAgICAgICBleGVjKGYie2Z1bmN9ID0ge2NsYXNzX25hbWUubG93ZXIoKX0ue2Z1bmN9IixnbG9iYWxzX2RpY3QpCgpkZWYgY2hlY2tfaWZfZWxlbWVudF9hbnlfaXNfaW5fbGlzdChlbGVtZW50cyxfbGlzdCk6CiAgICByZXR1cm4gYW55KF8gaW4gX2xpc3QgZm9yIF8gaW4gZWxlbWVudHMpCiAgICAKY2xhc3MgQ2xhc3M6CiAgICBkZWYgX19pbml0X18oc2VsZixjbGFzc19zZWxmLGNsYXNzX25hbWUpOgogICAgICAgIHNlbGYuc2VsZj1jbGFzc19zZWxmCiAgICAgICAgc2VsZi5uYW1lPWNsYXNzX25hbWUKICAgIAogICAgZGVmIGNsYXNzX2luaXQoc2VsZixfbmFtZSxfZmxhZ3MsX2Z1bmN0aW9uLF93b3JrZGlyKToKICAgICAgICBzZWxmLnNlbGYubmFtZT1fbmFtZQogICAgICAgIAogICAgICAgIHNlbGYuc2VsZi5mbGFncz1nZXRfdmFsdWUoX2ZsYWdzLFtdKQogICAgICAgIAogICAgICAgIHNlbGYuc2VsZi5mdW5jdGlvbj1nZXRfdmFsdWUoX2Z1bmN0aW9uLCIiKQogICAgICAgIAogICAgICAgIGlmIHNlbGYuc2VsZi5mdW5jdGlvbiBub3QgaW4gWyJpbml0Il06CiAgICAgICAgICAgIGlmIG5vdCBvcy5wYXRoLmlzZGlyKGYie1JPT1R9L3tzZWxmLnNlbGYubmFtZX0iKToKICAgICAgICAgICAgICAgICByYWlzZSBEb2VzTm90RXhpc3QoKQogICAgICAgICAgICAgICAgIHJldHVybgogICAgICAgICAgICBvcy5jaGRpcihmIntST09UfS97c2VsZi5zZWxmLm5hbWV9IikKICAgICAgICBzZWxmLnNlbGYud29ya2Rpcj1fd29ya2RpcgogICAgICAgIAogICAgZGVmIHN0b3Aoc2VsZik6CiAgICAgICAgaWYgIlN0b3BwZWQiIGluIHNlbGYuc2VsZi5TdGF0dXMoKToKICAgICAgICAgICAgcmV0dXJuIGYiU2VydmljZSB7c2VsZi5zZWxmLm5hbWV9IGlzIGFscmVhZHkgc3RvcHBlZCIKICAgICAgICAKICAgICAgICBmb3IgcHJvY2VzcyBpbiBbIm1haW4iLCAiYXV4aWxpYXJ5Il06CiAgICAgICAgICAgIGZvciBwaWQgaW4gc2VsZi5zZWxmLlBzKHByb2Nlc3MpOgogICAgICAgICAgICAgICAgdHJ5OgogICAgICAgICAgICAgICAgICAgIG9zLmtpbGwocGlkLHNpZ25hbC5TSUdURVJNKQogICAgICAgICAgICAgICAgICAgIHdoaWxlIGNoZWNrX3BpZChwaWQpOgogICAgICAgICAgICAgICAgICAgICAgICB0aW1lLnNsZWVwKDAuMjUpCiAgICAgICAgICAgICAgICBleGNlcHQgUHJvY2Vzc0xvb2t1cEVycm9yOgogICAgICAgICAgICAgICAgICAgIHBhc3MKICAgICAgICAKICAgIGRlZiBjbGVhbnVwX2FmdGVyX3N0b3Aoc2VsZik6CiAgICAgICAgZm9yIGVuZGluZyBpbiBbImxvZyIsImxvY2siXToKICAgICAgICAgICAgdHJ5OgogICAgICAgICAgICAgICBvcy5yZW1vdmUoZiJ7VEVNUERJUn0ve3NlbGYubmFtZX1fe3NlbGYuc2VsZi5uYW1lfS57ZW5kaW5nfSIpCiAgICAgICAgICAgIGV4Y2VwdCBGaWxlTm90Rm91bmRFcnJvcjoKICAgICAgICAgICAgICAgIHBhc3MKCiAgICBkZWYgcmVzdGFydChzZWxmKToKICAgICAgICByZXR1cm4gW3NlbGYuc2VsZi5TdG9wKCksc2VsZi5zZWxmLlN0YXJ0KCldCiAgICAKICAgIGRlZiBnZXRfbWFpbl9wcm9jZXNzKHNlbGYpOgogICAgICAgIGlmIG5vdCBvcy5wYXRoLmlzZmlsZShmIntURU1QRElSfS97c2VsZi5uYW1lfV97c2VsZi5zZWxmLm5hbWV9LmxvY2siKToKICAgICAgICAgICAgICAgIHJldHVybiBbXQogICAgICAgIGVsc2U6CiAgICAgICAgICAgIHJldHVybiBsaXN0KG1hcChpbnQsW19bMTpdIGZvciBfIGluIHNoZWxsX2NvbW1hbmQoWyJsc29mIiwiLUZwIiwiLXciLGYie1RFTVBESVJ9L3tzZWxmLm5hbWV9X3tzZWxmLnNlbGYubmFtZX0ubG9jayJdKS5zcGxpdGxpbmVzKCldKSkKICAgIAogICAgZGVmIGxpc3Qoc2VsZik6CiAgICAgICAgcmV0dXJuIHNlbGYuc2VsZi5uYW1lCiAgICAgICAgCiAgICBkZWYgd29ya2RpcihzZWxmLHdvcmtfZGlyKToKICAgICAgICAjUmVtb3ZlIHRyYWlsaW5nIHNsYXNoZXMsIGJ1dCBvbmx5IGZvciBzdHJpbmdzIHRoYXQgYXJlIG5vdCAvCiAgICAgICAgaWYgd29ya19kaXIuZW5kc3dpdGgoJy8nKSBhbmQgbGVuKHdvcmtfZGlyKT4xOgogICAgICAgICAgICB3b3JrX2Rpcj13b3JrX2Rpcls6LTFdCiAgICAgICAgICAgIAogICAgICAgIGlmIHdvcmtfZGlyLnN0YXJ0c3dpdGgoIi8iKToKICAgICAgICAgICAgc2VsZi5zZWxmLndvcmtkaXI9d29ya19kaXIKICAgICAgICBlbHNlOiAgICAKICAgICAgICAgICAgc2VsZi5zZWxmLndvcmtkaXIrPScvJyt3b3JrX2RpcgogICAgICAgIAogICAgICAgICNSZW1vdmUgcmVwZWF0ZWQgLyBpbiB3b3JrZGlyCiAgICAgICAgc2VsZi5zZWxmLndvcmtkaXI9cmUuc3ViKHInKC8pXDErJywgcidcMScsc2VsZi5zZWxmLndvcmtkaXIpCgogICAgZGVmIGVkaXQoc2VsZik6CiAgICAgICAgaWYgIkVuYWJsZWQiIGluIHNlbGYuc2VsZi5TdGF0dXMoKToKICAgICAgICAgICAgc2hlbGxfY29tbWFuZChbb3MuZ2V0ZW52KCJFRElUT1IiLCJ2aSIpLGYie1JPT1R9L3tzZWxmLnNlbGYubmFtZX0ve3NlbGYubmFtZX0ucHkiXSxzdGRvdXQ9Tm9uZSkKICAgICAgICBlbHNlOgogICAgICAgICAgICBzaGVsbF9jb21tYW5kKFtvcy5nZXRlbnYoIkVESVRPUiIsInZpIiksZiJ7Uk9PVH0ve3NlbGYuc2VsZi5uYW1lfS8ue3NlbGYubmFtZX0ucHkiXSxzdGRvdXQ9Tm9uZSkKCiAgICBkZWYgc3RhdHVzKHNlbGYpOgogICAgICAgIHN0YXR1cz1bXQogICAgICAgIGlmIG9zLnBhdGguaXNmaWxlKGYie1RFTVBESVJ9L3tzZWxmLm5hbWV9X3tzZWxmLnNlbGYubmFtZX0ubG9nIik6CiAgICAgICAgICAgIHN0YXR1cys9WyJTdGFydGVkIl0KICAgICAgICBlbHNlOgogICAgICAgICAgICBzdGF0dXMrPVsiU3RvcHBlZCJdCiAgICAgICAgCiAgICAgICAgaWYgb3MucGF0aC5leGlzdHMoZiJ7Uk9PVH0ve3NlbGYuc2VsZi5uYW1lfS97c2VsZi5uYW1lfS5weSIpOgogICAgICAgICAgICBzdGF0dXMrPVsiRW5hYmxlZCJdCiAgICAgICAgZWxzZToKICAgICAgICAgICAgc3RhdHVzKz1bIkRpc2FibGVkIl0KICAgICAgICByZXR1cm4gc3RhdHVzCiAgICAKICAgIGRlZiBlbmFibGUoc2VsZik6CiAgICAgICAgaWYgIkVuYWJsZWQiIGluIHNlbGYuc2VsZi5TdGF0dXMoKToKICAgICAgICAgICAgcmV0dXJuIFtmIntzZWxmLm5hbWV9IGlzIGFscmVhZHkgZW5hYmxlZCJdCiAgICAgICAgZWxzZToKICAgICAgICAgICAgb3MucmVuYW1lKGYie1JPT1R9L3tzZWxmLnNlbGYubmFtZX0vLntzZWxmLm5hbWV9LnB5IixmIntST09UfS97c2VsZi5zZWxmLm5hbWV9L3tzZWxmLm5hbWV9LnB5IikKICAgICAgICAKICAgICAgICBpZiAnLS1ub3cnIGluIHNlbGYuc2VsZi5mbGFnczoKICAgICAgICAgICAgcmV0dXJuIFtzZWxmLnNlbGYuU3RhcnQoKV0KCiAgICBkZWYgbG9vcChzZWxmLGNvbW1hbmQsZGVsYXk9NjApOgogICAgICAgIGlmIGlzaW5zdGFuY2UoY29tbWFuZCxzdHIpOgogICAgICAgICAgICBkZWYgZnVuYygpOgogICAgICAgICAgICAgICAgd2hpbGUgVHJ1ZToKICAgICAgICAgICAgICAgICAgICBzZWxmLnNlbGYuUnVuKGNvbW1hbmQpCiAgICAgICAgICAgICAgICAgICAgc2VsZi5zZWxmLldhaXQoZGVsYXkpCiAgICAgICAgZWxzZToKICAgICAgICAgICAgZGVmIGZ1bmMoKToKICAgICAgICAgICAgICAgIHdoaWxlIFRydWU6ICAKICAgICAgICAgICAgICAgICAgICBjb21tYW5kKCkKICAgICAgICAgICAgICAgICAgICBzZWxmLnNlbGYuV2FpdChkZWxheSkKICAgICAgICB0aHJlYWRpbmcuVGhyZWFkKHRhcmdldD1mdW5jLGRhZW1vbj1UcnVlKS5zdGFydCgpCiAgICAgICAKICAgIGRlZiBkaXNhYmxlKHNlbGYpOgogICAgICAgIGlmICJEaXNhYmxlZCIgaW4gc2VsZi5zZWxmLlN0YXR1cygpOgogICAgICAgICAgICByZXR1cm4gW2Yie3NlbGYuc2VsZi5uYW1lfSBpcyBhbHJlYWR5IGRpc2FibGVkIl0KICAgICAgICBlbHNlOgogICAgICAgICAgICBvcy5yZW5hbWUoZiJ7Uk9PVH0ve3NlbGYuc2VsZi5uYW1lfS97c2VsZi5uYW1lfS5weSIsZiJ7Uk9PVH0ve3NlbGYuc2VsZi5uYW1lfS8ue3NlbGYubmFtZX0ucHkiKQogICAgICAgIAogICAgICAgIGlmICctLW5vdycgaW4gc2VsZi5zZWxmLmZsYWdzOgogICAgICAgICAgICByZXR1cm4gW3NlbGYuc2VsZi5TdG9wKCldCgogICAgZGVmIGxvZyhzZWxmKToKICAgICAgICBzaGVsbF9jb21tYW5kKFsibGVzcyIsIitHIiwiLWYiLCItciIsZiJ7VEVNUERJUn0ve3NlbGYubmFtZX1fe3NlbGYuc2VsZi5uYW1lfS5sb2ciXSxzdGRvdXQ9Tm9uZSkKICAgIAogICAgZGVmIGRlbGV0ZShzZWxmKToKICAgICAgICBzZWxmLnNlbGYuU3RvcCgpCiAgICAgICAgc2h1dGlsLnJtdHJlZShmIntST09UfS97c2VsZi5zZWxmLm5hbWV9IikKICAgIAogICAgZGVmIHdhdGNoKHNlbGYpOgogICAgICAgIHNoZWxsX2NvbW1hbmQoWyJ0YWlsIiwiLWYiLCItLWZvbGxvdz1uYW1lIixmIntURU1QRElSfS97c2VsZi5uYW1lfV97c2VsZi5zZWxmLm5hbWV9LmxvZyJdLHN0ZG91dD1Ob25lKQoK').decode("utf-8"),utils_module.__dict__)
sys.modules["utils"]=utils_module

import utils

CLASS_NAME="Service"
utils.ROOT=ROOT=utils.get_root_directory(CLASS_NAME)
utils.TEMPDIR=TEMPDIR=utils.get_tempdir()

NAMES,FLAGS,FUNCTION=utils.extract_arguments()

utils.NAMES=NAMES
utils.ROOT=ROOT

SHELL=os.getenv('SHELL','bash')
SHELL_CWD=os.environ.get("PWD")

def list_services(*args, **kwargs):
    return utils.list_items_in_root(*args, FLAGS,CLASS_NAME,**kwargs)    

def flatten(*args, **kwargs):
    return utils.flatten_list(*args, **kwargs)

def print_result(*args, **kwargs):
    return utils.print_list(*args, **kwargs)

def split_by_char(*args, **kwargs):
    return utils.split_by_char(*args, **kwargs)
    
def Shell(*args, **kwargs):
    return utils.shell_command(*args, **kwargs)


ServiceDoesNotExist=utils.DoesNotExist
    
class Service:
    def __init__(self,_name,_flags=None,_function=None,_env=None,_workdir='.'):
        self.Class = utils.Class(self,CLASS_NAME.lower())
        self.Class.class_init(_name,_flags,_function,_workdir)
        
        self.env=utils.get_value(_env,f"export SERVICE_NAME={self.name}")
    
    #Functions to be used in *service.py
    def Run(self,command="",pipe=False,track=True):
        with open(f"{TEMPDIR}/service_{self.name}.log","a+") as log_file:
            log_file.write(f"Command: {command}\n")
            log_file.flush()

            #Pipe output to variable
            if pipe:
                stdout=subprocess.PIPE
                stderr=subprocess.DEVNULL
            #Print output to file
            else:
                stdout=log_file
                stderr=subprocess.STDOUT
            return Shell(f"{self.env if track else 'true'}; cd {self.workdir}; {command}",stdout=stdout,stderr=stderr,arbitrary=True)
    
    def Ps(self,process="auxiliary"):
        
        #Find main process
        if process=="main":
            return self.Class.get_main_process()
            
        #Find processes running under main Start script
        elif process=="auxiliary":
            processes=Shell(["ps","auxwwe"]).splitlines()
            processes=[_.split()[1] for _ in processes if f"SERVICE_NAME={self.name}" in _]
            return list(map(int,processes))

    
    def Env(self,*args, **kwargs):
        self.env=utils.add_environment_variable_to_string(self.env,*args, **kwargs)
    
    def Container(self,_container=None):
        #Convience --- if conainer name is not specified, it will assume that the container is the same name as the service
        
        if not _container:
            _container=self.name
            
        self.Down(f"container stop {_container}")
        self.Run(f"container start {_container}",track=False)
        
        
        with open(f"{TEMPDIR}/service_{self.name}.log","a+") as f:
            Shell(["tail","-f","-n","+1",f"{TEMPDIR}/container_{_container}.log"],stdout=f,block=False)
    
    def Down(self,func):
        #Yes, this decorator stuff is absolutely neccessary, anything else will not work
    
        if isinstance(func,str):
            #So func won't be overwritten
            func_str=func
            def func():
                Shell(func_str,arbitrary=True)
        def decorator_Exit(exit_func,func):
            def new_Exit(*args, **kwargs):
                exit_func(*args, **kwargs)
                func()
            return new_Exit
        self.Exit=decorator_Exit(self.Exit,func)
        signal.signal(signal.SIGTERM,decorator_Exit(self.Exit,exit))
        
    def Loop(self,*args, **kwargs):
        self.Class.loop(*args, **kwargs)
        #Run(f'(while true; do "{command}"; sleep {delay}; done)')

    def Wait(self,*args, **kwargs):
        utils.wait(*args, **kwargs)
    
    def Exit(self,signum,frame):
        pass
        
    #Commands      
    def Start(self):
        
        if "Started" in self.Status():
            return f"Service {self.name} is already started"
        
        if os.path.exists("data"):
            os.chdir("data")
        
        if "Enabled" in self.Status():
            service_file="service.py"
        else:
            service_file=".service.py"
        
        #Fork process, so it can run in the background
        pid=os.fork()
        
        #If child, run code, then exit 
        if pid==0:
            #Open a lock file so I can find it with lsof later
            signal.signal(signal.SIGTERM,self.Exit)
            lock_file=open(f"{TEMPDIR}/service_{self.name}.lock","w+")
            
            #Run *service.py
            with open(f"{ROOT}/{self.name}/{service_file}") as f:
                code=f.read()
            exec(code,globals(),locals())
            
            #Don't exit script yet.
            self.Wait()
            exit()
       
    def Stop(self):
        output=[self.Class.stop()]
        self.Class.cleanup_after_stop()
        return output
        
    def Restart(self):
        return self.Class.restart()
    
    
    def List(self):
        return self.Class.list()
    
    def Workdir(self,work_dir):
        self.Class.workdir(work_dir)

    def Init(self):
        os.makedirs(f"{ROOT}/{self.name}",exist_ok=True)
        os.chdir(f"{ROOT}/{self.name}")
        os.makedirs("data",exist_ok=True)
        with open(f".{CLASS_NAME.lower()}.py",'a'):
            pass
        
        if '--no-edit' not in self.flags:
            self.Edit()

    def Edit(self):
        self.Class.edit()
    def Status(self):
        return self.Class.status()
    
    def Enable(self):
        return self.Class.enable()

            
    def Disable(self):
        return self.Class.disable()

    def Log(self):
        self.Class.log()
    
    def Delete(self):
        self.Class.delete()
    
    def Watch(self):
        self.Class.watch()


NAMES=list_services(NAMES)
for name in NAMES: 
    try:
        service=Service(name,FLAGS,FUNCTION)
    except ServiceDoesNotExist:
        print(f"Service {name} does not exist")
        continue
    
    utils.export_methods_globally(CLASS_NAME,globals())
    
    result=utils.execute_class_method(eval(f"{CLASS_NAME.lower()}"),FUNCTION)
    print_result(result)
        

    
